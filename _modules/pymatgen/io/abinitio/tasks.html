<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pymatgen.io.abinitio.tasks &mdash; pymatgen 3.1.7 documentation</title>
    
    <link rel="stylesheet" href="../../../../_static/proBlue.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '3.1.7',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
    <link rel="top" title="pymatgen 3.1.7 documentation" href="../../../../index.html" />
    <link rel="up" title="Module code" href="../../../index.html" />
 
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33990148-1']);
  _gaq.push(['_trackPageview']);
</script>

  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">pymatgen 3.1.7 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pymatgen.io.abinitio.tasks</h1><div class="highlight"><pre>
<span class="c"># coding: utf-8</span>
<span class="c"># Copyright (c) Pymatgen Development Team.</span>
<span class="c"># Distributed under the terms of the MIT License.</span>
<span class="sd">&quot;&quot;&quot;Classes defining Abinit calculations.&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">unicode_literals</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">yaml</span>
<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> <span class="n">pprint</span>
<span class="kn">from</span> <span class="nn">atomicfile</span> <span class="kn">import</span> <span class="n">AtomicFile</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="kn">import</span> <span class="nb">map</span><span class="p">,</span> <span class="nb">zip</span><span class="p">,</span> <span class="n">StringIO</span>
<span class="kn">from</span> <span class="nn">pydispatch</span> <span class="kn">import</span> <span class="n">dispatcher</span>
<span class="kn">from</span> <span class="nn">monty.termcolor</span> <span class="kn">import</span> <span class="n">colored</span>
<span class="kn">from</span> <span class="nn">monty.serialization</span> <span class="kn">import</span> <span class="n">loadfn</span>
<span class="kn">from</span> <span class="nn">monty.string</span> <span class="kn">import</span> <span class="n">is_string</span><span class="p">,</span> <span class="n">list_strings</span>
<span class="kn">from</span> <span class="nn">monty.io</span> <span class="kn">import</span> <span class="n">FileLock</span>
<span class="kn">from</span> <span class="nn">monty.collections</span> <span class="kn">import</span> <span class="n">AttrDict</span><span class="p">,</span> <span class="n">Namespace</span>
<span class="kn">from</span> <span class="nn">monty.functools</span> <span class="kn">import</span> <span class="n">lazy_property</span><span class="p">,</span> <span class="n">return_none_if_raise</span>
<span class="kn">from</span> <span class="nn">monty.json</span> <span class="kn">import</span> <span class="n">MontyDecoder</span>
<span class="kn">from</span> <span class="nn">monty.fnmatch</span> <span class="kn">import</span> <span class="n">WildCard</span>
<span class="kn">from</span> <span class="nn">pymatgen.core.units</span> <span class="kn">import</span>  <span class="n">Memory</span> <span class="c">#Time,</span>
<span class="kn">from</span> <span class="nn">pymatgen.util.num_utils</span> <span class="kn">import</span> <span class="n">maxloc</span>
<span class="kn">from</span> <span class="nn">pymatgen.serializers.json_coders</span> <span class="kn">import</span> <span class="n">PMGSONable</span><span class="p">,</span> <span class="n">json_pretty_dump</span><span class="p">,</span> <span class="n">pmg_serialize</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">File</span><span class="p">,</span> <span class="n">Directory</span><span class="p">,</span> <span class="n">irdvars_for_ext</span><span class="p">,</span> <span class="n">abi_splitext</span><span class="p">,</span> <span class="n">abi_extensions</span><span class="p">,</span> <span class="n">FilepathFixer</span><span class="p">,</span> <span class="n">Condition</span><span class="p">,</span> <span class="n">SparseHistogram</span>
<span class="kn">from</span> <span class="nn">.strategies</span> <span class="kn">import</span> <span class="n">StrategyWithInput</span><span class="p">,</span> <span class="n">OpticInput</span>
<span class="kn">from</span> <span class="nn">.qadapters</span> <span class="kn">import</span> <span class="n">make_qadapter</span><span class="p">,</span> <span class="n">QueueAdapter</span><span class="p">,</span> <span class="n">slurm_parse_timestr</span>
<span class="kn">from</span> <span class="nn">.db</span> <span class="kn">import</span> <span class="n">DBConnector</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">abiinspect</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">events</span>


<span class="n">__author__</span> <span class="o">=</span> <span class="s">&quot;Matteo Giantomassi&quot;</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s">&quot;Copyright 2013, The Materials Project&quot;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s">&quot;0.1&quot;</span>
<span class="n">__maintainer__</span> <span class="o">=</span> <span class="s">&quot;Matteo Giantomassi&quot;</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s">&quot;TaskManager&quot;</span><span class="p">,</span>
    <span class="s">&quot;ParalHintsParser&quot;</span><span class="p">,</span>
    <span class="s">&quot;ScfTask&quot;</span><span class="p">,</span>
    <span class="s">&quot;NscfTask&quot;</span><span class="p">,</span>
    <span class="s">&quot;RelaxTask&quot;</span><span class="p">,</span>
    <span class="s">&quot;DdkTask&quot;</span><span class="p">,</span>
    <span class="s">&quot;PhononTask&quot;</span><span class="p">,</span>
    <span class="s">&quot;SigmaTask&quot;</span><span class="p">,</span>
    <span class="s">&quot;OpticTask&quot;</span><span class="p">,</span>
    <span class="s">&quot;AnaddbTask&quot;</span><span class="p">,</span>
<span class="p">]</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>


<span class="c"># Tools and helper functions.</span>

<span class="k">def</span> <span class="nf">straceback</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Returns a string with the traceback.&quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">traceback</span>
    <span class="k">return</span> <span class="n">traceback</span><span class="o">.</span><span class="n">format_exc</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">GridFsFile</span><span class="p">(</span><span class="n">AttrDict</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">fs_id</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&quot;b&quot;</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">GridFsFile</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">,</span> <span class="n">fs_id</span><span class="o">=</span><span class="n">fs_id</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">NodeResults</span><span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">PMGSONable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dictionary used to store the most important results produced by a Node.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">JSON_SCHEMA</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">&quot;type&quot;</span><span class="p">:</span> <span class="s">&quot;object&quot;</span><span class="p">,</span>
        <span class="s">&quot;properties&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s">&quot;node_id&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s">&quot;type&quot;</span><span class="p">:</span> <span class="s">&quot;integer&quot;</span><span class="p">,</span> <span class="s">&quot;required&quot;</span><span class="p">:</span> <span class="bp">True</span><span class="p">},</span>
            <span class="s">&quot;node_finalized&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s">&quot;type&quot;</span><span class="p">:</span> <span class="s">&quot;boolean&quot;</span><span class="p">,</span> <span class="s">&quot;required&quot;</span><span class="p">:</span> <span class="bp">True</span><span class="p">},</span>
            <span class="s">&quot;node_history&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s">&quot;type&quot;</span><span class="p">:</span> <span class="s">&quot;array&quot;</span><span class="p">,</span> <span class="s">&quot;required&quot;</span><span class="p">:</span> <span class="bp">True</span><span class="p">},</span>
            <span class="s">&quot;node_class&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s">&quot;type&quot;</span><span class="p">:</span> <span class="s">&quot;string&quot;</span><span class="p">,</span> <span class="s">&quot;required&quot;</span><span class="p">:</span> <span class="bp">True</span><span class="p">},</span>
            <span class="s">&quot;node_name&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s">&quot;type&quot;</span><span class="p">:</span> <span class="s">&quot;string&quot;</span><span class="p">,</span> <span class="s">&quot;required&quot;</span><span class="p">:</span> <span class="bp">True</span><span class="p">},</span>
            <span class="s">&quot;node_status&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s">&quot;type&quot;</span><span class="p">:</span> <span class="s">&quot;string&quot;</span><span class="p">,</span> <span class="s">&quot;required&quot;</span><span class="p">:</span> <span class="bp">True</span><span class="p">},</span>
            <span class="s">&quot;in&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s">&quot;type&quot;</span><span class="p">:</span> <span class="s">&quot;object&quot;</span><span class="p">,</span> <span class="s">&quot;required&quot;</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span> <span class="s">&quot;description&quot;</span><span class="p">:</span> <span class="s">&quot;dictionary with input parameters&quot;</span><span class="p">},</span>
            <span class="s">&quot;out&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s">&quot;type&quot;</span><span class="p">:</span> <span class="s">&quot;object&quot;</span><span class="p">,</span> <span class="s">&quot;required&quot;</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span> <span class="s">&quot;description&quot;</span><span class="p">:</span> <span class="s">&quot;dictionary with the output results&quot;</span><span class="p">},</span>
            <span class="s">&quot;exceptions&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s">&quot;type&quot;</span><span class="p">:</span> <span class="s">&quot;array&quot;</span><span class="p">,</span> <span class="s">&quot;required&quot;</span><span class="p">:</span> <span class="bp">True</span><span class="p">},</span>
            <span class="s">&quot;files&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s">&quot;type&quot;</span><span class="p">:</span> <span class="s">&quot;object&quot;</span><span class="p">,</span> <span class="s">&quot;required&quot;</span><span class="p">:</span> <span class="bp">True</span><span class="p">},</span>
        <span class="p">},</span>
    <span class="p">}</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_node</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize an instance of `NodeResults` from a `Node` subclass.&quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">node_id</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">node_id</span><span class="p">,</span>
            <span class="n">node_finalized</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">finalized</span><span class="p">,</span>
            <span class="n">node_history</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">history</span><span class="p">),</span>
            <span class="n">node_name</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> 
            <span class="n">node_class</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span>
            <span class="n">node_status</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">status</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">Results</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">NodeResults</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">node</span>

        <span class="k">if</span> <span class="s">&quot;in&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="p">[</span><span class="s">&quot;in&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Namespace</span><span class="p">()</span>
        <span class="k">if</span> <span class="s">&quot;out&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="p">[</span><span class="s">&quot;out&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Namespace</span><span class="p">()</span>
        <span class="k">if</span> <span class="s">&quot;exceptions&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="p">[</span><span class="s">&quot;exceptions&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="s">&quot;files&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="p">[</span><span class="s">&quot;files&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Namespace</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">exceptions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="s">&quot;exceptions&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gridfs_files</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List with the absolute paths of the files to be put in GridFs.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="s">&quot;files&quot;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">register_gridfs_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function registers the files that will be saved in GridFS.</span>
<span class="sd">        kwargs is a dictionary mapping the key associated to the file (usually the extension)</span>
<span class="sd">        to the absolute path. By default, files are assumed to be in binary form, for formatted files</span>
<span class="sd">        one should pass a tuple (&quot;filepath&quot;, &quot;t&quot;).</span>

<span class="sd">        Example::</span>

<span class="sd">            results.register_gridfs(GSR=&quot;path/to/GSR.nc&quot;, text_file=(&quot;/path/to/txt_file&quot;, &quot;t&quot;))</span>

<span class="sd">        The GSR file is a binary file, whereas text_file is a text file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="s">&quot;b&quot;</span> 
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span> <span class="n">v</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">v</span>
            <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">GridFsFile</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="n">v</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
            
        <span class="bp">self</span><span class="p">[</span><span class="s">&quot;files&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">push_exceptions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">exceptions</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">exc</span> <span class="ow">in</span> <span class="n">exceptions</span><span class="p">:</span>
            <span class="n">newstr</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">newstr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exceptions</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="s">&quot;exceptions&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">newstr</span><span class="p">,]</span>

    <span class="nd">@pmg_serialize</span>
    <span class="k">def</span> <span class="nf">as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                                                                                
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&quot;@module&quot;</span><span class="p">,</span> <span class="s">&quot;@class&quot;</span><span class="p">)})</span>

    <span class="k">def</span> <span class="nf">json_dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="n">json_pretty_dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">as_dict</span><span class="p">(),</span> <span class="n">filename</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">json_load</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">loadfn</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">validate_json_schema</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">validictory</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">validictory</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">JSON_SCHEMA</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">pprint</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">update_collection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">collection</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update a mongodb collection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span> 
        <span class="n">flow</span> <span class="o">=</span> <span class="n">node</span> <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_flow</span> <span class="k">else</span> <span class="n">node</span><span class="o">.</span><span class="n">flow</span>

        <span class="c"># Build the key used to store the entry in the document.</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_task</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="s">&quot;w&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s">&quot;_t&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">is_work</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="s">&quot;w&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>

        <span class="n">db</span> <span class="o">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">database</span>

        <span class="c"># Save files with GridFs first in order to get the ID.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridfs_files</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">gridfs</span>
            <span class="n">fs</span> <span class="o">=</span> <span class="n">gridfs</span><span class="o">.</span><span class="n">GridFS</span><span class="p">(</span><span class="n">db</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ext</span><span class="p">,</span> <span class="n">gridfile</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridfs_files</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;gridfs: about to put file:&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">gridfile</span><span class="p">))</span>
                <span class="c"># Here we set gridfile.fs_id that will be stored in the mondodb document</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">gridfile</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="s">&quot;r&quot;</span> <span class="o">+</span> <span class="n">gridfile</span><span class="o">.</span><span class="n">mode</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                        <span class="n">gridfile</span><span class="o">.</span><span class="n">fs_id</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">gridfile</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">IOError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">flow</span><span class="o">.</span><span class="n">mongo_id</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># Flow does not have a mongo_id, allocate doc for the flow and save its id.</span>
            <span class="n">flow</span><span class="o">.</span><span class="n">mongo_id</span> <span class="o">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">insert</span><span class="p">({})</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&quot;Creating flow.mongo_id&quot;</span><span class="p">,</span> <span class="n">flow</span><span class="o">.</span><span class="n">mongo_id</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">flow</span><span class="o">.</span><span class="n">mongo_id</span><span class="p">))</span>

        <span class="c"># Get the document from flow.mongo_id and update it.</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">find_one</span><span class="p">({</span><span class="s">&quot;_id&quot;</span><span class="p">:</span> <span class="n">flow</span><span class="o">.</span><span class="n">mongo_id</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> is already in doc!&quot;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>
        <span class="n">doc</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span>

        <span class="n">collection</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
        <span class="c">#collection.update({&#39;_id&#39;:mongo_id}, {&quot;$set&quot;: doc}, upsert=False)</span>


<span class="k">class</span> <span class="nc">TaskResults</span><span class="p">(</span><span class="n">NodeResults</span><span class="p">):</span>

    <span class="n">JSON_SCHEMA</span> <span class="o">=</span> <span class="n">NodeResults</span><span class="o">.</span><span class="n">JSON_SCHEMA</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> 
    <span class="n">JSON_SCHEMA</span><span class="p">[</span><span class="s">&quot;properties&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">&quot;executable&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s">&quot;type&quot;</span><span class="p">:</span> <span class="s">&quot;string&quot;</span><span class="p">,</span> <span class="s">&quot;required&quot;</span><span class="p">:</span> <span class="bp">True</span><span class="p">},</span>
    <span class="p">}</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_node</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize an instance from an AbinitTask instance.&quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">TaskResults</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">from_node</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>

        <span class="n">new</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="n">executable</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">executable</span><span class="p">,</span>
            <span class="c">#executable_version:</span>
            <span class="c">#task_events=</span>
            <span class="n">pseudos</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">pseudos</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span>
            <span class="c">#input=task.strategy</span>
        <span class="p">)</span>

        <span class="n">new</span><span class="o">.</span><span class="n">register_gridfs_files</span><span class="p">(</span>
            <span class="n">run_abi</span><span class="o">=</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">input_file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="s">&quot;t&quot;</span><span class="p">),</span>
            <span class="n">run_abo</span><span class="o">=</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="s">&quot;t&quot;</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">new</span>


<span class="k">class</span> <span class="nc">ParalConf</span><span class="p">(</span><span class="n">AttrDict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This object store the parameters associated to one </span>
<span class="sd">    of the possible parallel configurations reported by ABINIT.</span>
<span class="sd">    Essentially it is a dictionary whose values can also be accessed </span>
<span class="sd">    as attributes. It also provides default values for selected keys</span>
<span class="sd">    that might not be present in the ABINIT dictionary.</span>

<span class="sd">    Example:</span>

<span class="sd">        --- !Autoparal</span>
<span class="sd">        info: </span>
<span class="sd">            version: 1</span>
<span class="sd">            autoparal: 1</span>
<span class="sd">            max_ncpus: 108</span>
<span class="sd">        configurations:</span>
<span class="sd">            -   tot_ncpus: 2         # Total number of CPUs</span>
<span class="sd">                mpi_ncpus: 2         # Number of MPI processes.</span>
<span class="sd">                omp_ncpus: 1         # Number of OMP threads (1 if not present)</span>
<span class="sd">                mem_per_cpu: 10      # Estimated memory requirement per MPI processor in Megabytes.</span>
<span class="sd">                efficiency: 0.4      # 1.0 corresponds to an &quot;expected&quot; optimal efficiency (strong scaling).</span>
<span class="sd">                vars: {              # Dictionary with the variables that should be added to the input.</span>
<span class="sd">                      varname1: varvalue1</span>
<span class="sd">                      varname2: varvalue2</span>
<span class="sd">                      }</span>
<span class="sd">            -</span>
<span class="sd">        ...</span>

<span class="sd">    For paral_kgb we have:</span>
<span class="sd">    nproc     npkpt  npspinor    npband     npfft    bandpp    weight   </span>
<span class="sd">       108       1         1        12         9         2        0.25</span>
<span class="sd">       108       1         1       108         1         2       27.00</span>
<span class="sd">        96       1         1        24         4         1        1.50</span>
<span class="sd">        84       1         1        12         7         2        0.25</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_DEFAULTS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">&quot;omp_ncpus&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>     
        <span class="s">&quot;mem_per_cpu&quot;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> 
        <span class="s">&quot;vars&quot;</span><span class="p">:</span> <span class="p">{}</span>       
    <span class="p">}</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ParalConf</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="c"># Add default values if not already in self.</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_DEFAULTS</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">stream</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>
        <span class="n">pprint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="n">stream</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">stream</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>

    <span class="c"># TODO: Change name in abinit</span>
    <span class="c"># Remove tot_ncpus from Abinit</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_cores</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_procs</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">omp_threads</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mem_per_proc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mem_per_cpu</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mpi_procs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_ncpus</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">omp_threads</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">omp_ncpus</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">speedup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimated speedup reported by ABINIT.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">efficiency</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cores</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tot_mem</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimated total memory in Mbs (computed from mem_per_proc)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mem_per_proc</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_procs</span>


<span class="k">class</span> <span class="nc">ParalHintsError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base error class for `ParalHints`.&quot;&quot;&quot;</span>


<div class="viewcode-block" id="ParalHintsParser"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.ParalHintsParser">[docs]</a><span class="k">class</span> <span class="nc">ParalHintsParser</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="n">Error</span> <span class="o">=</span> <span class="n">ParalHintsError</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># Used to push error strings.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_errors</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">(</span><span class="n">maxlen</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

<div class="viewcode-block" id="ParalHintsParser.add_error"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.ParalHintsParser.add_error">[docs]</a>    <span class="k">def</span> <span class="nf">add_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">errmsg</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="ParalHintsParser.parse"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.ParalHintsParser.parse">[docs]</a>    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read the `AutoParal` section (YAML format) from filename.</span>
<span class="sd">        Assumes the file contains only one section.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">abiinspect</span><span class="o">.</span><span class="n">YamlTokenizer</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">r</span><span class="p">:</span>
            <span class="n">doc</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">next_doc_with_tag</span><span class="p">(</span><span class="s">&quot;!Autoparal&quot;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">doc</span><span class="o">.</span><span class="n">text_notag</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">ParalHints</span><span class="p">(</span><span class="n">info</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s">&quot;info&quot;</span><span class="p">],</span> <span class="n">confs</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s">&quot;configurations&quot;</span><span class="p">])</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">traceback</span>
                <span class="n">sexc</span> <span class="o">=</span> <span class="n">traceback</span><span class="o">.</span><span class="n">format_exc</span><span class="p">()</span>
                <span class="n">err_msg</span> <span class="o">=</span> <span class="s">&quot;Wrong YAML doc:</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n\n</span><span class="s">Exception&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">doc</span><span class="o">.</span><span class="n">text</span><span class="p">,</span> <span class="n">sexc</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_error</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
                <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>

</div></div>
<span class="k">class</span> <span class="nc">ParalHints</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Iterable with the hints for the parallel execution reported by ABINIT.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Error</span> <span class="o">=</span> <span class="n">ParalHintsError</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">confs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">info</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_confs</span> <span class="o">=</span> <span class="p">[</span><span class="n">ParalConf</span><span class="p">(</span><span class="o">**</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">confs</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_confs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_confs</span><span class="o">.</span><span class="n">__iter__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_confs</span><span class="o">.</span><span class="n">__len__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">conf</span><span class="p">)</span> <span class="k">for</span> <span class="n">conf</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">max_cores</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Maximum number of cores.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">mpi_procs</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="n">omp_threads</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">max_mem_per_proc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Maximum memory per MPI process.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">mem_per_proc</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span> 

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">max_speedup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Maximum speedup.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">speedup</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span> 

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">max_efficiency</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Maximum parallel efficiency.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">efficiency</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span> 

    <span class="nd">@pmg_serialize</span>
    <span class="k">def</span> <span class="nf">as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s">&quot;info&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;confs&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_confs</span><span class="p">}</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">info</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s">&quot;info&quot;</span><span class="p">],</span> <span class="n">confs</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s">&quot;confs&quot;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shallow copy of self.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">select_with_condition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all the configurations that do not satisfy the given condition.</span>

<span class="sd">            Args:</span>
<span class="sd">                condition: dict or :class:`Condition` object with operators expressed with a Mongodb-like syntax</span>
<span class="sd">                key: Selects the sub-dictionary on which condition is applied, e.g. key=&quot;vars&quot;</span>
<span class="sd">                    if we have to filter the configurations depending on the values in vars</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">condition</span> <span class="o">=</span> <span class="n">Condition</span><span class="o">.</span><span class="n">as_condition</span><span class="p">(</span><span class="n">condition</span><span class="p">)</span>
        <span class="n">new_confs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">conf</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="c"># Select the object on which condition is applied</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">conf</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">AttrDict</span><span class="p">(</span><span class="n">conf</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="n">add_it</span> <span class="o">=</span> <span class="n">condition</span><span class="p">(</span><span class="n">obj</span><span class="o">=</span><span class="n">obj</span><span class="p">)</span>
            <span class="c">#if key is &quot;vars&quot;: print(&quot;conf&quot;, conf, &quot;added:&quot;, add_it)</span>
            <span class="k">if</span> <span class="n">add_it</span><span class="p">:</span> <span class="n">new_confs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">conf</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_confs</span> <span class="o">=</span> <span class="n">new_confs</span>

    <span class="k">def</span> <span class="nf">sort_by_efficiency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sort the configurations in place. items with highest efficiency come first&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_confs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">c</span><span class="o">.</span><span class="n">efficiency</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sort_by_speedup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sort the configurations in place. items with highest speedup come first&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_confs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">c</span><span class="o">.</span><span class="n">speedup</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sort_by_mem_per_proc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sort the configurations in place. items with lowest memory per proc come first.&quot;&quot;&quot;</span>
        <span class="c"># Avoid sorting if mem_per_cpu is not available.</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">mem_per_proc</span> <span class="o">&gt;</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_confs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">c</span><span class="o">.</span><span class="n">mem_per_proc</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">multidimensional_optimization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">priorities</span><span class="o">=</span><span class="p">(</span><span class="s">&quot;speedup&quot;</span><span class="p">,</span> <span class="s">&quot;efficiency&quot;</span><span class="p">)):</span>
        <span class="c"># Mapping property --&gt; options passed to sparse_histogram</span>
        <span class="n">opts</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">speedup</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">step</span><span class="o">=</span><span class="mf">1.0</span><span class="p">),</span> <span class="n">efficiency</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">step</span><span class="o">=</span><span class="mf">0.1</span><span class="p">),</span> <span class="n">mem_per_proc</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">memory</span><span class="o">=</span><span class="mi">1024</span><span class="p">))</span>
        <span class="c">#opts = dict(zip(priorities, bin_widths))</span>
                                                                                                   
        <span class="n">opt_confs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_confs</span>
        <span class="k">for</span> <span class="n">priority</span> <span class="ow">in</span> <span class="n">priorities</span><span class="p">:</span>
            <span class="n">histogram</span> <span class="o">=</span> <span class="n">SparseHistogram</span><span class="p">(</span><span class="n">opt_confs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">priority</span><span class="p">),</span> <span class="o">**</span><span class="n">opts</span><span class="p">[</span><span class="n">priority</span><span class="p">])</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">priority</span> <span class="o">==</span> <span class="s">&quot;mem_per_proc&quot;</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">opt_confs</span> <span class="o">=</span> <span class="n">histogram</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>

        <span class="c">#histogram.plot(show=True, savefig=&quot;hello.pdf&quot;)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">info</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">confs</span><span class="o">=</span><span class="n">opt_confs</span><span class="p">)</span>

    <span class="c">#def histogram_efficiency(self, step=0.1):</span>
    <span class="c">#    &quot;&quot;&quot;Returns a :class:`SparseHistogram` with configuration grouped by parallel efficiency.&quot;&quot;&quot;</span>
    <span class="c">#    return SparseHistogram(self._confs, key=lambda c: c.efficiency, step=step)</span>

    <span class="c">#def histogram_speedup(self, step=1.0):</span>
    <span class="c">#    &quot;&quot;&quot;Returns a :class:`SparseHistogram` with configuration grouped by parallel speedup.&quot;&quot;&quot;</span>
    <span class="c">#    return SparseHistogram(self._confs, key=lambda c: c.speedup, step=step)</span>

    <span class="c">#def histogram_memory(self, step=1024):</span>
    <span class="c">#    &quot;&quot;&quot;Returns a :class:`SparseHistogram` with configuration grouped by memory.&quot;&quot;&quot;</span>
    <span class="c">#    return SparseHistogram(self._confs, key=lambda c: c.speedup, step=step)</span>

    <span class="c">#def filter(self, qadapter):</span>
    <span class="c">#    &quot;&quot;&quot;Return a new list of configurations that can be executed on the `QueueAdapter` qadapter.&quot;&quot;&quot;</span>
    <span class="c">#    new_confs = [pconf for pconf in self if qadapter.can_run_pconf(pconf)]</span>
    <span class="c">#    return self.__class__(info=self.info, confs=new_confs)</span>

    <span class="k">def</span> <span class="nf">get_ordered_with_policy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">policy</span><span class="p">,</span> <span class="n">max_ncpus</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort and return a new list of configurations ordered according to the :class:`TaskPolicy` policy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Build new list since we are gonna change the object in place.</span>
        <span class="n">hints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">confs</span><span class="o">=</span><span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">num_cores</span> <span class="o">&lt;=</span> <span class="n">max_ncpus</span><span class="p">])</span>

        <span class="c"># First select the configurations satisfying the condition specified by the user (if any)</span>
        <span class="n">bkp_hints</span> <span class="o">=</span> <span class="n">hints</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">policy</span><span class="o">.</span><span class="n">condition</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Applying condition </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">policy</span><span class="o">.</span><span class="n">condition</span><span class="p">))</span>
            <span class="n">hints</span><span class="o">.</span><span class="n">select_with_condition</span><span class="p">(</span><span class="n">policy</span><span class="o">.</span><span class="n">condition</span><span class="p">)</span>

            <span class="c"># Undo change if no configuration fullfills the requirements.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">hints</span><span class="p">:</span>
                <span class="n">hints</span> <span class="o">=</span> <span class="n">bkp_hints</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&quot;Empty list of configurations after policy.condition&quot;</span><span class="p">)</span>

        <span class="c"># Now filter the configurations depending on the values in vars</span>
        <span class="n">bkp_hints</span> <span class="o">=</span> <span class="n">hints</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">policy</span><span class="o">.</span><span class="n">vars_condition</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Applying vars_condition </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">policy</span><span class="o">.</span><span class="n">vars_condition</span><span class="p">))</span>
            <span class="n">hints</span><span class="o">.</span><span class="n">select_with_condition</span><span class="p">(</span><span class="n">policy</span><span class="o">.</span><span class="n">vars_condition</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s">&quot;vars&quot;</span><span class="p">)</span>

            <span class="c"># Undo change if no configuration fullfills the requirements.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">hints</span><span class="p">:</span>
                <span class="n">hints</span> <span class="o">=</span> <span class="n">bkp_hints</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&quot;Empty list of configurations after policy.vars_condition&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">policy</span><span class="o">.</span><span class="n">autoparal_priorities</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c"># Example: hints.sort_by_speedup()</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="n">hints</span><span class="p">,</span> <span class="s">&quot;sort_by_&quot;</span> <span class="o">+</span> <span class="n">policy</span><span class="o">.</span><span class="n">autoparal_priorities</span><span class="p">[</span><span class="mi">0</span><span class="p">])()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hints</span> <span class="o">=</span> <span class="n">hints</span><span class="o">.</span><span class="n">multidimensional_optimization</span><span class="p">(</span><span class="n">priorities</span><span class="o">=</span><span class="n">policy</span><span class="o">.</span><span class="n">autoparal_priorities</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hints</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;len(hints) == 0&quot;</span><span class="p">)</span>

        <span class="c">#TODO: make sure that num_cores == 1 is never selected when we have more than one configuration</span>
        <span class="c">#if len(hints) &gt; 1:</span>
        <span class="c">#    hints.select_with_condition(dict(num_cores={&quot;$eq&quot;: 1)))</span>

        <span class="c"># Return final (orderded ) list of configurations (best first).</span>
        <span class="k">return</span> <span class="n">hints</span>


<span class="k">class</span> <span class="nc">TaskPolicy</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This object stores the parameters used by the :class:`TaskManager` to </span>
<span class="sd">    create the submission script and/or to modify the ABINIT variables </span>
<span class="sd">    governing the parallel execution. A `TaskPolicy` object contains </span>
<span class="sd">    a set of variables that specify the launcher, as well as the options</span>
<span class="sd">    and the condition used to select the optimal configuration for the parallel run </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">as_policy</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts an object obj into a `:class:`TaskPolicy. Accepts:</span>

<span class="sd">            * None</span>
<span class="sd">            * TaskPolicy</span>
<span class="sd">            * dict-like object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># Use default policy.</span>
            <span class="k">return</span> <span class="n">TaskPolicy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">cls</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">obj</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Mapping</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="o">**</span><span class="n">obj</span><span class="p">)</span> 
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Don&#39;t know how to convert type </span><span class="si">%s</span><span class="s"> to </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="n">cls</span><span class="p">))</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">autodoc</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s">    autoparal: 0 to disable the autoparal feature (default 1 i.e. autoparal is on)</span>
<span class="s">    condition: condition used to filter the autoparal configurations (Mongodb-like syntax). </span>
<span class="s">               Default: empty </span>
<span class="s">    vars_condition: condition used to filter the list of ABINIT variables reported autoparal </span>
<span class="s">                    (Mongodb-like syntax). Default: empty</span>
<span class="s">    frozen_timeout: A job is considered to be frozen and its status is set to Error if no change to </span>
<span class="s">                    the output file has been done for frozen_timeout seconds. Accepts int with seconds or </span>
<span class="s">                    string in slurm form i.e. days-hours:minutes:seconds. Default: 1 hour.</span>
<span class="s">    precedence:</span>
<span class="s">    autoparal_priorities:</span>
<span class="s">&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        See autodoc</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoparal</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;autoparal&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">condition</span> <span class="o">=</span> <span class="n">Condition</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;condition&quot;</span><span class="p">,</span> <span class="p">{}))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vars_condition</span> <span class="o">=</span> <span class="n">Condition</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;vars_condition&quot;</span><span class="p">,</span> <span class="p">{}))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">precedence</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;precedence&quot;</span><span class="p">,</span> <span class="s">&quot;autoparal_conf&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoparal_priorities</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;autoparal_priorities&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;speedup&quot;</span><span class="p">])</span>
        <span class="c">#self.autoparal_priorities = kwargs.pop(&quot;autoparal_priorities&quot;, [&quot;speedup&quot;, &quot;efficiecy&quot;, &quot;memory&quot;]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frozen_timeout</span> <span class="o">=</span> <span class="n">slurm_parse_timestr</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;frozen_timeout&quot;</span><span class="p">,</span> <span class="s">&quot;0-1&quot;</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Found invalid keywords in policy section:</span><span class="se">\n</span><span class="s"> </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

        <span class="c"># Consistency check.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">precedence</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&quot;qadapter&quot;</span><span class="p">,</span> <span class="s">&quot;autoparal_conf&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Wrong value for policy.precedence, should be qadapter or autoparal_conf&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&quot;_&quot;</span><span class="p">):</span> <span class="k">continue</span>
            <span class="n">app</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
        <span class="k">return</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>


<div class="viewcode-block" id="TaskManager"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.TaskManager">[docs]</a><span class="k">class</span> <span class="nc">TaskManager</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A `TaskManager` is responsible for the generation of the job script and the submission </span>
<span class="sd">    of the task, as well as for the specification of the parameters passed to the resource manager</span>
<span class="sd">    (e.g. Slurm, PBS ...) and/or the run-time specification of the ABINIT variables governing the parallel execution. </span>
<span class="sd">    A `TaskManager` delegates the generation of the submission script and the submission of the task to the :class:`QueueAdapter`. </span>
<span class="sd">    A `TaskManager` has a :class:`TaskPolicy` that governs the specification of the parameters for the parallel executions.</span>
<span class="sd">    Ideally, the TaskManager should be the **main entry point** used by the task to deal with job submission/optimization</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">YAML_FILE</span> <span class="o">=</span> <span class="s">&quot;manager.yml&quot;</span>
    <span class="n">USER_CONFIG_DIR</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s">&quot;HOME&quot;</span><span class="p">),</span> <span class="s">&quot;.abinit&quot;</span><span class="p">,</span> <span class="s">&quot;abipy&quot;</span><span class="p">)</span>

    <span class="n">ENTRIES</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;policy&quot;</span><span class="p">,</span> <span class="s">&quot;qadapters&quot;</span><span class="p">,</span> <span class="s">&quot;db_connector&quot;</span><span class="p">}</span>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="TaskManager.autodoc"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.TaskManager.autodoc">[docs]</a>    <span class="k">def</span> <span class="nf">autodoc</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.db</span> <span class="kn">import</span> <span class="n">DBConnector</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span>
<span class="s"># TaskManager configuration file (YAML Format)</span>

<span class="s">policy: </span>
<span class="s">    # Dictionary with options used to control the execution of the tasks.</span>

<span class="s">qadapters:  </span>
<span class="s">    # List of qadapters objects (mandatory)</span>
<span class="s">    -  # qadapter_1</span>
<span class="s">    -  # qadapter_2</span>

<span class="s">db_connector: </span>
<span class="s">    # Connection to MongoDB database (optional)</span>

<span class="s">##########################################</span>
<span class="s"># Individual entries are documented below:</span>
<span class="s">##########################################</span>

<span class="s">&quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;policy: &quot;</span> <span class="o">+</span> <span class="n">TaskPolicy</span><span class="o">.</span><span class="n">autodoc</span><span class="p">()</span> <span class="o">+</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;qadapter: &quot;</span> <span class="o">+</span> <span class="n">QueueAdapter</span><span class="o">.</span><span class="n">autodoc</span><span class="p">()</span> <span class="o">+</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;db_connector: &quot;</span> <span class="o">+</span> <span class="n">DBConnector</span><span class="o">.</span><span class="n">autodoc</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">s</span>
</div>
    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="TaskManager.from_user_config"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.TaskManager.from_user_config">[docs]</a>    <span class="k">def</span> <span class="nf">from_user_config</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the :class:`TaskManager` from the YAML file &#39;taskmanager.yaml&#39;.</span>
<span class="sd">        Search first in the working directory and then in the abipy configuration directory.</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError if file is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Try in the current directory.</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="n">cls</span><span class="o">.</span><span class="n">YAML_FILE</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

        <span class="c"># Try in the configuration directory.</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">USER_CONFIG_DIR</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">YAML_FILE</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;Cannot locate </span><span class="si">%s</span><span class="s"> neither in current directory nor in </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">YAML_FILE</span><span class="p">,</span> <span class="n">path</span><span class="p">))</span>
</div>
    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="TaskManager.from_file"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.TaskManager.from_file">[docs]</a>    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read the configuration parameters from the Yaml file filename.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&quot;Error while reading TaskManager parameters from file </span><span class="si">%s</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>
            <span class="k">raise</span> 
</div>
    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="TaskManager.from_string"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.TaskManager.from_string">[docs]</a>    <span class="k">def</span> <span class="nf">from_string</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an instance from string s containing a YAML dictionary.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
</div>
    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="TaskManager.from_dict"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.TaskManager.from_dict">[docs]</a>    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an instance from a dictionary.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">ENTRIES</span><span class="p">})</span>
</div>
<div class="viewcode-block" id="TaskManager.as_dict"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.TaskManager.as_dict">[docs]</a>    <span class="k">def</span> <span class="nf">as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span>
</div>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            policy:None</span>
<span class="sd">            qadapters:List of qadapters in YAML format</span>
<span class="sd">            db_connector:Dictionary with data used to connect to the database (optional)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Keep a copy of kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">policy</span> <span class="o">=</span> <span class="n">TaskPolicy</span><span class="o">.</span><span class="n">as_policy</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;policy&quot;</span><span class="p">,</span> <span class="bp">None</span><span class="p">))</span>

        <span class="c"># Initialize database connector (if specified)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">db_connector</span> <span class="o">=</span> <span class="n">DBConnector</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;db_connector&quot;</span><span class="p">,</span> <span class="p">{}))</span>

        <span class="c"># Build list of QAdapters. Neglect entry if priority == 0 or `enabled: no&quot;</span>
        <span class="n">qads</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;qadapters&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;enabled&quot;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span> <span class="k">continue</span> 
            <span class="n">qad</span> <span class="o">=</span> <span class="n">make_qadapter</span><span class="p">(</span><span class="o">**</span><span class="n">d</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">qad</span><span class="o">.</span><span class="n">priority</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>    
                <span class="n">qads</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qad</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">qad</span><span class="o">.</span><span class="n">priority</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>    
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;qadapter cannot have negative priority:</span><span class="se">\n</span><span class="s"> </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">qad</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">qads</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Received emtpy list of qadapters&quot;</span><span class="p">)</span>
        <span class="c">#if len(qads) != 1:</span>
        <span class="c">#    raise NotImplementedError(&quot;For the time being multiple qadapters are not supported! Please use one adapter&quot;)</span>

        <span class="c"># Order qdapters according to priority.</span>
        <span class="n">qads</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">qads</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">q</span><span class="p">:</span> <span class="n">q</span><span class="o">.</span><span class="n">priority</span><span class="p">)</span>
        <span class="n">priorities</span> <span class="o">=</span> <span class="p">[</span><span class="n">q</span><span class="o">.</span><span class="n">priority</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">qads</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">priorities</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">priorities</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Two or more qadapters have same priority. This is not allowed. Check taskmanager.yml&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_qads</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qadpos</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">qads</span><span class="p">),</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Found invalid keywords in the taskmanager file:</span><span class="se">\n</span><span class="s"> </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>

<div class="viewcode-block" id="TaskManager.to_shell_manager"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.TaskManager.to_shell_manager">[docs]</a>    <span class="k">def</span> <span class="nf">to_shell_manager</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mpi_procs</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new `TaskManager` with the same parameters as self but replace the :class:`QueueAdapter`</span>
<span class="sd">        with a :class:`ShellAdapter` with mpi_procs so that we can submit the job without passing through the queue.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">my_kwargs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="p">)</span>
        <span class="n">my_kwargs</span><span class="p">[</span><span class="s">&quot;policy&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">TaskPolicy</span><span class="p">(</span><span class="n">autoparal</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">my_kwargs</span><span class="p">[</span><span class="s">&quot;qadapters&quot;</span><span class="p">]:</span>
            <span class="c">#print(&quot;before&quot;, d[&quot;queue&quot;][&quot;qtype&quot;])</span>
            <span class="n">d</span><span class="p">[</span><span class="s">&quot;queue&quot;</span><span class="p">][</span><span class="s">&quot;qtype&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;shell&quot;</span>
            <span class="n">d</span><span class="p">[</span><span class="s">&quot;limits&quot;</span><span class="p">][</span><span class="s">&quot;min_cores&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpi_procs</span>
            <span class="n">d</span><span class="p">[</span><span class="s">&quot;limits&quot;</span><span class="p">][</span><span class="s">&quot;max_cores&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpi_procs</span>

        <span class="c">#print(my_kwargs)</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="o">**</span><span class="n">my_kwargs</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">set_mpi_procs</span><span class="p">(</span><span class="n">mpi_procs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new</span>
</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if we are submitting jobs via a queue manager.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">QTYPE</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="s">&quot;shell&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">qads</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List of :class:`QueueAdapter` objects sorted according to priorities (highest comes first)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qads</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">qadapter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The qadapter used to submit jobs.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qads</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_qadpos</span><span class="p">]</span>

<div class="viewcode-block" id="TaskManager.select_qadapter"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.TaskManager.select_qadapter">[docs]</a>    <span class="k">def</span> <span class="nf">select_qadapter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pconfs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a list of parallel configurations, pconfs, this method select an `optimal` configuration</span>
<span class="sd">        according to some criterion as well as the :class:`QueueAdapter` to use.</span>

<span class="sd">        Args:</span>
<span class="sd">            pconfs: :class:`ParalHints` object with the list of parallel configurations</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`ParallelConf` object with the `optimal` configuration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Order the list of configurations according to policy.</span>
        <span class="n">policy</span><span class="p">,</span> <span class="n">max_ncpus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">policy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_cores</span>
        <span class="n">pconfs</span> <span class="o">=</span> <span class="n">pconfs</span><span class="o">.</span><span class="n">get_ordered_with_policy</span><span class="p">(</span><span class="n">policy</span><span class="p">,</span> <span class="n">max_ncpus</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">policy</span><span class="o">.</span><span class="n">precedence</span> <span class="o">==</span> <span class="s">&quot;qadapter&quot;</span><span class="p">:</span>
            <span class="c"># Try to run on the qadapter with the highest priority.</span>
            <span class="k">for</span> <span class="n">qadpos</span><span class="p">,</span> <span class="n">qad</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qads</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">pconf</span> <span class="ow">in</span> <span class="n">pconfs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">qad</span><span class="o">.</span><span class="n">can_run_pconf</span><span class="p">(</span><span class="n">pconf</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_use_qadpos_pconf</span><span class="p">(</span><span class="n">qadpos</span><span class="p">,</span> <span class="n">pconf</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">pconf</span>

        <span class="k">elif</span> <span class="n">policy</span><span class="o">.</span><span class="n">precedence</span> <span class="o">==</span> <span class="s">&quot;autoparal_conf&quot;</span><span class="p">:</span>
            <span class="c"># Try to run on the first pconf irrespectively of the priority of the qadapter.</span>
            <span class="k">for</span> <span class="n">pconf</span> <span class="ow">in</span> <span class="n">pconfs</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">qadpos</span><span class="p">,</span> <span class="n">qad</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qads</span><span class="p">):</span>
                   <span class="k">if</span> <span class="n">qad</span><span class="o">.</span><span class="n">can_run_pconf</span><span class="p">(</span><span class="n">pconf</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_use_qadpos_pconf</span><span class="p">(</span><span class="n">qadpos</span><span class="p">,</span> <span class="n">pconf</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">pconf</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Wrong value of policy.precedence = </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">policy</span><span class="o">.</span><span class="n">precedence</span><span class="p">)</span>

        <span class="c"># No qadapter could be found</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;Cannot find qadapter for this run!&quot;</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_use_qadpos_pconf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qadpos</span><span class="p">,</span> <span class="n">pconf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This function is called when we have accepted the :class:`ParalConf` pconf&quot;&quot;&quot;</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">_qadpos</span> <span class="o">=</span> <span class="n">qadpos</span> 

        <span class="c"># Change the number of MPI/OMP cores.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_mpi_procs</span><span class="p">(</span><span class="n">pconf</span><span class="o">.</span><span class="n">mpi_procs</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_omp</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_omp_threads</span><span class="p">(</span><span class="n">pconf</span><span class="o">.</span><span class="n">omp_threads</span><span class="p">)</span>
                                                                      
        <span class="c"># Set memory per proc.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_mem_per_proc</span><span class="p">(</span><span class="n">pconf</span><span class="o">.</span><span class="n">mem_per_proc</span><span class="p">)</span>

<div class="viewcode-block" id="TaskManager.__str__"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.TaskManager.__str__">[docs]</a>    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String representation.&quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>
        <span class="c">#app(&quot;[Task policy]\n%s&quot; % str(self.policy))</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">qad</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qads</span><span class="p">):</span>
            <span class="n">app</span><span class="p">(</span><span class="s">&quot;[Qadapter </span><span class="si">%d</span><span class="s">]</span><span class="se">\n</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">qad</span><span class="p">)))</span>
        <span class="n">app</span><span class="p">(</span><span class="s">&quot;Qadapter selected: </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qadpos</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_db</span><span class="p">:</span>
            <span class="n">app</span><span class="p">(</span><span class="s">&quot;[MongoDB database]:&quot;</span><span class="p">)</span>
            <span class="n">app</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">db_connector</span><span class="p">))</span>

        <span class="k">return</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_db</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if we are using MongoDB database&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">db_connector</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_omp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if we are using OpenMP parallelization.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">has_omp</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_cores</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Total number of CPUs used to run the task.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">num_cores</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mpi_procs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of MPI processes.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">mpi_procs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mem_per_proc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Memory per MPI process.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">mem_per_proc</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">omp_threads</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of OpenMP threads&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">omp_threads</span>

<div class="viewcode-block" id="TaskManager.deepcopy"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.TaskManager.deepcopy">[docs]</a>    <span class="k">def</span> <span class="nf">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deep copy of self.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TaskManager.set_mpi_procs"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.TaskManager.set_mpi_procs">[docs]</a>    <span class="k">def</span> <span class="nf">set_mpi_procs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mpi_procs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the number of MPI nodes to use.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">set_mpi_procs</span><span class="p">(</span><span class="n">mpi_procs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TaskManager.set_omp_threads"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.TaskManager.set_omp_threads">[docs]</a>    <span class="k">def</span> <span class="nf">set_omp_threads</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">omp_threads</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the number of OpenMp threads to use.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">set_omp_threads</span><span class="p">(</span><span class="n">omp_threads</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TaskManager.set_mem_per_proc"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.TaskManager.set_mem_per_proc">[docs]</a>    <span class="k">def</span> <span class="nf">set_mem_per_proc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mem_mb</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the memory (in Megabytes) per CPU.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">set_mem_per_proc</span><span class="p">(</span><span class="n">mem_mb</span><span class="p">)</span>
</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_cores</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Maximum number of cores that can be used.</span>
<span class="sd">        This value is mainly used in the autoparal part to get the list of possible configurations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">max_cores</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qads</span><span class="p">)</span>

<div class="viewcode-block" id="TaskManager.get_njobs_in_queue"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.TaskManager.get_njobs_in_queue">[docs]</a>    <span class="k">def</span> <span class="nf">get_njobs_in_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">username</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        returns the number of jobs in the queue,</span>
<span class="sd">        returns None when the number of jobs cannot be determined.</span>

<span class="sd">        Args:</span>
<span class="sd">            username: (str) the username of the jobs to count (default is to autodetect)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">get_njobs_in_queue</span><span class="p">(</span><span class="n">username</span><span class="o">=</span><span class="n">username</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TaskManager.cancel"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.TaskManager.cancel">[docs]</a>    <span class="k">def</span> <span class="nf">cancel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">job_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cancel the job. Returns exit status.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">cancel</span><span class="p">(</span><span class="n">job_id</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TaskManager.write_jobfile"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.TaskManager.write_jobfile">[docs]</a>    <span class="k">def</span> <span class="nf">write_jobfile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write the submission script. return the path of the script&quot;&quot;&quot;</span>
        <span class="n">script</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">get_script_str</span><span class="p">(</span>
            <span class="n">job_name</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> 
            <span class="n">launch_dir</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span>
            <span class="n">executable</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">executable</span><span class="p">,</span>
            <span class="n">qout_path</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">qout_file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
            <span class="n">qerr_path</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">qerr_file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
            <span class="n">stdin</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">files_file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> 
            <span class="n">stdout</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">log_file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
            <span class="n">stderr</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">stderr_file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c"># Write the script.</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">job_file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="s">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
            <span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">script</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">task</span><span class="o">.</span><span class="n">job_file</span><span class="o">.</span><span class="n">path</span>
</div>
<div class="viewcode-block" id="TaskManager.launch"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.TaskManager.launch">[docs]</a>    <span class="k">def</span> <span class="nf">launch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build the input files and submit the task via the :class:`Qadapter` </span>

<span class="sd">        Args:</span>
<span class="sd">            task: :class:`TaskObject`</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            Process object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Build the task </span>
        <span class="n">task</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>

        <span class="c"># Write the submission script</span>
        <span class="n">script_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">write_jobfile</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
        <span class="n">task</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">S_SUB</span><span class="p">)</span>

        <span class="c"># Submit the task and save the queue id.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">qjob</span><span class="p">,</span> <span class="n">process</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">submit_to_queue</span><span class="p">(</span><span class="n">script_file</span><span class="p">)</span>
            <span class="n">task</span><span class="o">.</span><span class="n">set_qjob</span><span class="p">(</span><span class="n">qjob</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">process</span>
        <span class="k">except</span> <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">MaxNumLaunchesError</span><span class="p">:</span>
            <span class="c"># TODO: Here we should try to switch to another qadapter</span>
            <span class="c"># 1) Find a new parallel configuration in those stores in task.pconfs</span>
            <span class="c"># 2) Change the input file.</span>
            <span class="c"># 3) Regenerate the submission script</span>
            <span class="c"># 4) Relaunch</span>
            <span class="k">raise</span>
</div>
<div class="viewcode-block" id="TaskManager.get_collection"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.TaskManager.get_collection">[docs]</a>    <span class="k">def</span> <span class="nf">get_collection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the MongoDB collection used to store the results.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_connector</span><span class="o">.</span><span class="n">get_collection</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TaskManager.increase_resources"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.TaskManager.increase_resources">[docs]</a>    <span class="k">def</span> <span class="nf">increase_resources</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># with GW calculations in mind with GW mem = 10, </span>
        <span class="c"># the response fuction is in memory and not distributed</span>
        <span class="c"># we need to increas memory if jobs fail ...</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">more_mem_per_proc</span><span class="p">()</span>


<span class="c"># The code below initializes a counter from a file when the module is imported </span>
<span class="c"># and save the counter&#39;s updated value automatically when the program terminates </span>
<span class="c"># without relying on the application making an explicit call into this module at termination.</span></div></div>
<span class="n">conf_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s">&quot;HOME&quot;</span><span class="p">),</span> <span class="s">&quot;.abinit&quot;</span><span class="p">,</span> <span class="s">&quot;abipy&quot;</span><span class="p">)</span>

<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">conf_dir</span><span class="p">):</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">conf_dir</span><span class="p">)</span>

<span class="n">_COUNTER_FILE</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">conf_dir</span><span class="p">,</span> <span class="s">&quot;nodecounter&quot;</span><span class="p">)</span>
<span class="k">del</span> <span class="n">conf_dir</span>

<span class="k">try</span><span class="p">:</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">_COUNTER_FILE</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">_fh</span><span class="p">:</span>
        <span class="n">_COUNTER</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">_fh</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>

<span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
    <span class="n">_COUNTER</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>


<span class="k">def</span> <span class="nf">get_newnode_id</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a new node identifier used both for `Task` and `Work` objects.</span>

<span class="sd">    .. warnings:</span>
<span class="sd">        The id is unique inside the same python process so be careful when </span>
<span class="sd">        Works and Tasks are constructed at run-time or when threads are used.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_COUNTER</span>
    <span class="n">_COUNTER</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">_COUNTER</span>


<span class="k">def</span> <span class="nf">save_lastnode_id</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Save the id of the last node created.&quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">FileLock</span><span class="p">(</span><span class="n">_COUNTER_FILE</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">AtomicFile</span><span class="p">(</span><span class="n">_COUNTER_FILE</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
            <span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">_COUNTER</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">atexit</span>
<span class="n">atexit</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">save_lastnode_id</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">FakeProcess</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This object is attached to a :class:`Task` instance if the task has not been submitted</span>
<span class="sd">    This trick allows us to simulate a process that is still running so that </span>
<span class="sd">    we can safely poll task.process.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">poll</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">wait</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;Cannot wait a FakeProcess&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">communicate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;Cannot communicate with a FakeProcess&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">kill</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;Cannot kill a FakeProcess&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">returncode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">None</span>


<span class="k">class</span> <span class="nc">Product</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A product represents an output file produced by ABINIT instance.</span>
<span class="sd">    This file is needed to start another `Task` or another `Work`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ext</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            ext: ABINIT file extension</span>
<span class="sd">            path: (asbolute) filepath</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ext</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">abi_extensions</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Extension </span><span class="si">%s</span><span class="s"> has not been registered in the internal database&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">ext</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ext</span> <span class="o">=</span> <span class="n">ext</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">filepath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Build a :class:`Product` instance from a filepath.&quot;&quot;&quot;</span>
        <span class="c"># Find the abinit extension.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">filepath</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">filepath</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span> <span class="ow">in</span> <span class="n">abi_extensions</span><span class="p">():</span>
                <span class="n">ext</span> <span class="o">=</span> <span class="n">filepath</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Cannot detect abinit extension in </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">filepath</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">ext</span><span class="p">,</span> <span class="n">filepath</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;File=</span><span class="si">%s</span><span class="s">, Extension=</span><span class="si">%s</span><span class="s">, &quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ext</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">filepath</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Absolute path of the file.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">path</span>

    <span class="k">def</span> <span class="nf">connecting_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dictionary with the ABINIT variables that </span>
<span class="sd">        must be used to make the code use this file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">irdvars_for_ext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ext</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Dependency</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This object describes the dependencies among the nodes of a calculation.</span>

<span class="sd">    A `Dependency` consists of a `Node` that produces a list of products (files) </span>
<span class="sd">    that are used by the other nodes (`Task` or `Work`) to start the calculation.</span>
<span class="sd">    One usually creates the object by calling work.register </span>

<span class="sd">    Example:</span>

<span class="sd">        # Register the SCF task in work.</span>
<span class="sd">        scf_task = work.register(scf_strategy)</span>

<span class="sd">        # Register the NSCF calculation and its dependency on the SCF run via deps.</span>
<span class="sd">        nscf_task = work.register(nscf_strategy, deps={scf_task: &quot;DEN&quot;})</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">exts</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            node: The task or the worfklow associated to the dependency or string with a filepath.</span>
<span class="sd">            exts: Extensions of the output files that are needed for running the other tasks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">as_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">exts</span> <span class="ow">and</span> <span class="n">is_string</span><span class="p">(</span><span class="n">exts</span><span class="p">):</span>
            <span class="n">exts</span> <span class="o">=</span> <span class="n">exts</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">exts</span> <span class="o">=</span> <span class="n">exts</span> <span class="ow">or</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;node </span><span class="si">%s</span><span class="s"> will produce: </span><span class="si">%s</span><span class="s"> &quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exts</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;node </span><span class="si">%s</span><span class="s"> will produce: </span><span class="si">%s</span><span class="s"> &quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exts</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">node</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The :class:`Node` associated to the dependency.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The status of the dependency, i.e. the status of the :class:`Node`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">status</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">products</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List of output files produces by self.&quot;&quot;&quot;</span>
        <span class="n">_products</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exts</span><span class="p">:</span>
            <span class="n">prod</span> <span class="o">=</span> <span class="n">Product</span><span class="p">(</span><span class="n">ext</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">opath_from_ext</span><span class="p">(</span><span class="n">ext</span><span class="p">))</span>
            <span class="n">_products</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prod</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_products</span>

    <span class="k">def</span> <span class="nf">connecting_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dictionary with the variables that must be added to the </span>
<span class="sd">        input file in order to connect this :class:`Node` to its dependencies.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">vars</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">products</span><span class="p">:</span>
            <span class="nb">vars</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">prod</span><span class="o">.</span><span class="n">connecting_vars</span><span class="p">())</span>

        <span class="k">return</span> <span class="nb">vars</span>

    <span class="k">def</span> <span class="nf">get_filepaths_and_exts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the paths of the output files produced by self and its extensions&quot;&quot;&quot;</span>
        <span class="n">filepaths</span> <span class="o">=</span> <span class="p">[</span><span class="n">prod</span><span class="o">.</span><span class="n">filepath</span> <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">products</span><span class="p">]</span>
        <span class="n">exts</span> <span class="o">=</span> <span class="p">[</span><span class="n">prod</span><span class="o">.</span><span class="n">ext</span> <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">products</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">filepaths</span><span class="p">,</span> <span class="n">exts</span>


<span class="k">def</span> <span class="nf">_2attrs</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">item</span> <span class="k">if</span> <span class="n">item</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="n">item</span><span class="p">,)</span>


<span class="k">class</span> <span class="nc">Status</span><span class="p">(</span><span class="nb">int</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This object is an integer representing the status of the `Node`.&quot;&quot;&quot;</span>

    <span class="c"># Possible status of the node. See monty.termocolor for the meaning of color, on_color and attrs.</span>
    <span class="n">_STATUS_INFO</span> <span class="o">=</span> <span class="p">[</span>
        <span class="c">#(value, name, color, on_color, attrs)</span>
        <span class="p">(</span><span class="mi">1</span><span class="p">,</span>  <span class="s">&quot;Initialized&quot;</span><span class="p">,</span>   <span class="bp">None</span>     <span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>         <span class="c"># Node has been initialized</span>
        <span class="p">(</span><span class="mi">2</span><span class="p">,</span>  <span class="s">&quot;Locked&quot;</span><span class="p">,</span>        <span class="bp">None</span>     <span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>         <span class="c"># Task is locked an must be explicitly unlocked by an external subject (Work).</span>
        <span class="p">(</span><span class="mi">3</span><span class="p">,</span>  <span class="s">&quot;Ready&quot;</span><span class="p">,</span>         <span class="bp">None</span>     <span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>         <span class="c"># Node is ready i.e. all the depencies of the node have status S_OK</span>
        <span class="p">(</span><span class="mi">4</span><span class="p">,</span>  <span class="s">&quot;Submitted&quot;</span><span class="p">,</span>     <span class="s">&quot;blue&quot;</span>   <span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>         <span class="c"># Node has been submitted (The `Task` is running or we have started to finalize the Work)</span>
        <span class="p">(</span><span class="mi">5</span><span class="p">,</span>  <span class="s">&quot;Running&quot;</span><span class="p">,</span>       <span class="s">&quot;magenta&quot;</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>         <span class="c"># Node is running.</span>
        <span class="p">(</span><span class="mi">6</span><span class="p">,</span>  <span class="s">&quot;Done&quot;</span><span class="p">,</span>          <span class="bp">None</span>     <span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>         <span class="c"># Node done, This does not imply that results are ok or that the calculation completed successfully</span>
        <span class="p">(</span><span class="mi">7</span><span class="p">,</span>  <span class="s">&quot;AbiCritical&quot;</span><span class="p">,</span>   <span class="s">&quot;red&quot;</span>    <span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>         <span class="c"># Node raised an Error by ABINIT.</span>
        <span class="p">(</span><span class="mi">8</span><span class="p">,</span>  <span class="s">&quot;QCritical&quot;</span><span class="p">,</span>     <span class="s">&quot;red&quot;</span>    <span class="p">,</span> <span class="s">&quot;on_white&quot;</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>   <span class="c"># Node raised an Error by submitting submission script, or by executing it</span>
        <span class="p">(</span><span class="mi">9</span><span class="p">,</span>  <span class="s">&quot;Unconverged&quot;</span><span class="p">,</span>   <span class="s">&quot;red&quot;</span>    <span class="p">,</span> <span class="s">&quot;on_yellow&quot;</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>  <span class="c"># This usually means that an iterative algorithm didn&#39;t converge.</span>
        <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s">&quot;Error&quot;</span><span class="p">,</span>         <span class="s">&quot;red&quot;</span>    <span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>         <span class="c"># Node raised an unrecoverable error, usually raised when an attempt to fix one of other types failed.</span>
        <span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="s">&quot;Completed&quot;</span><span class="p">,</span>     <span class="s">&quot;green&quot;</span>  <span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>         <span class="c"># Execution completed successfully.</span>
        <span class="c">#(11, &quot;Completed&quot;,     &quot;green&quot;  , None, &quot;underline&quot;),   </span>
    <span class="p">]</span>
    <span class="n">_STATUS2STR</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">([(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">_STATUS_INFO</span><span class="p">])</span>
    <span class="n">_STATUS2COLOR_OPTS</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">([(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">{</span><span class="s">&quot;color&quot;</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="s">&quot;on_color&quot;</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="s">&quot;attrs&quot;</span><span class="p">:</span> <span class="n">_2attrs</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">4</span><span class="p">])})</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">_STATUS_INFO</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;&lt;</span><span class="si">%s</span><span class="s">: </span><span class="si">%s</span><span class="s">, at </span><span class="si">%s</span><span class="s">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String representation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_STATUS2STR</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">as_status</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert obj into Status.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">obj</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span> <span class="k">else</span> <span class="n">cls</span><span class="o">.</span><span class="n">from_string</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_string</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a `Status` instance from its string representation.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">text</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">_STATUS2STR</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">text</span> <span class="o">==</span> <span class="n">s</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Wrong string </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">s</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_critical</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if status is critical.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&quot;AbiCritical&quot;</span><span class="p">,</span> <span class="s">&quot;QCritical&quot;</span><span class="p">,</span> <span class="s">&quot;Uncoverged&quot;</span><span class="p">,</span> <span class="s">&quot;Error&quot;</span><span class="p">)</span> 

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">color_opts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_STATUS2COLOR_OPTS</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">colored</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return colorized text used to print the status if the stream supports it.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">colored</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">color_opts</span><span class="p">)</span> 


<span class="k">class</span> <span class="nc">NodeHistory</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Logger-like object&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">NodeHistory</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;[</span><span class="si">%s</span><span class="s">]: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">asctime</span><span class="p">(),</span> <span class="n">msg</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">Node</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">with_metaclass</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span><span class="p">,</span> <span class="nb">object</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract base class defining the interface that must be </span>
<span class="sd">    implemented by the nodes of the calculation.</span>

<span class="sd">    Nodes are hashable and can be tested for equality</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Results</span> <span class="o">=</span> <span class="n">NodeResults</span>

    <span class="c"># Possible status of the node.</span>
    <span class="n">S_INIT</span> <span class="o">=</span> <span class="n">Status</span><span class="o">.</span><span class="n">from_string</span><span class="p">(</span><span class="s">&quot;Initialized&quot;</span><span class="p">)</span>
    <span class="n">S_LOCKED</span> <span class="o">=</span> <span class="n">Status</span><span class="o">.</span><span class="n">from_string</span><span class="p">(</span><span class="s">&quot;Locked&quot;</span><span class="p">)</span>
    <span class="n">S_READY</span> <span class="o">=</span> <span class="n">Status</span><span class="o">.</span><span class="n">from_string</span><span class="p">(</span><span class="s">&quot;Ready&quot;</span><span class="p">)</span>
    <span class="n">S_SUB</span> <span class="o">=</span> <span class="n">Status</span><span class="o">.</span><span class="n">from_string</span><span class="p">(</span><span class="s">&quot;Submitted&quot;</span><span class="p">)</span>
    <span class="n">S_RUN</span> <span class="o">=</span> <span class="n">Status</span><span class="o">.</span><span class="n">from_string</span><span class="p">(</span><span class="s">&quot;Running&quot;</span><span class="p">)</span>
    <span class="n">S_DONE</span> <span class="o">=</span> <span class="n">Status</span><span class="o">.</span><span class="n">from_string</span><span class="p">(</span><span class="s">&quot;Done&quot;</span><span class="p">)</span>
    <span class="n">S_ABICRITICAL</span> <span class="o">=</span> <span class="n">Status</span><span class="o">.</span><span class="n">from_string</span><span class="p">(</span><span class="s">&quot;AbiCritical&quot;</span><span class="p">)</span>
    <span class="n">S_QCRITICAL</span> <span class="o">=</span> <span class="n">Status</span><span class="o">.</span><span class="n">from_string</span><span class="p">(</span><span class="s">&quot;QCritical&quot;</span><span class="p">)</span>
    <span class="n">S_UNCONVERGED</span> <span class="o">=</span> <span class="n">Status</span><span class="o">.</span><span class="n">from_string</span><span class="p">(</span><span class="s">&quot;Unconverged&quot;</span><span class="p">)</span>
    <span class="n">S_ERROR</span> <span class="o">=</span> <span class="n">Status</span><span class="o">.</span><span class="n">from_string</span><span class="p">(</span><span class="s">&quot;Error&quot;</span><span class="p">)</span>
    <span class="n">S_OK</span> <span class="o">=</span> <span class="n">Status</span><span class="o">.</span><span class="n">from_string</span><span class="p">(</span><span class="s">&quot;Completed&quot;</span><span class="p">)</span>

    <span class="n">ALL_STATUS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">S_INIT</span><span class="p">,</span>
        <span class="n">S_LOCKED</span><span class="p">,</span>
        <span class="n">S_READY</span><span class="p">,</span>
        <span class="n">S_SUB</span><span class="p">,</span>
        <span class="n">S_RUN</span><span class="p">,</span>
        <span class="n">S_DONE</span><span class="p">,</span>
        <span class="n">S_ABICRITICAL</span><span class="p">,</span>
        <span class="n">S_QCRITICAL</span><span class="p">,</span>
        <span class="n">S_UNCONVERGED</span><span class="p">,</span>
        <span class="n">S_ERROR</span><span class="p">,</span>
        <span class="n">S_OK</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># Node identifier.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node_id</span> <span class="o">=</span> <span class="n">get_newnode_id</span><span class="p">()</span>

        <span class="c"># List of dependencies</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_deps</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c"># List of files (products) needed by this node.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_required_files</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c"># Used to push additional info during the execution. </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span> <span class="o">=</span> <span class="n">NodeHistory</span><span class="p">(</span><span class="n">maxlen</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

        <span class="c"># Actions performed to fix abicritical events.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_corrections</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">(</span><span class="n">maxlen</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

        <span class="c"># Set to true if the node has been finalized.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_status</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_INIT</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span> <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_id</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">node_id</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_id</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;&lt;</span><span class="si">%s</span><span class="s">, node_id=</span><span class="si">%s</span><span class="s">, workdir=</span><span class="si">%s</span><span class="s">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_id</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">relpath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">))</span>

        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c"># this usually happens when workdir has not been initialized</span>
            <span class="k">return</span> <span class="s">&quot;&lt;</span><span class="si">%s</span><span class="s">, node_id=</span><span class="si">%s</span><span class="s">, workdir=None&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_id</span><span class="p">)</span>
                                                                                            
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">as_node</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert obj into a Node instance.</span>

<span class="sd">        Return:</span>
<span class="sd">            obj if obj is a Node instance,</span>
<span class="sd">            cast obj to :class:`FileNode` instance of obj is a string.</span>
<span class="sd">            None if obj is None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">cls</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">obj</span>
        <span class="k">elif</span> <span class="n">is_string</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
            <span class="c"># Assume filepath.</span>
            <span class="k">return</span> <span class="n">FileNode</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">obj</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">obj</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Don&#39;t know how to convert </span><span class="si">%s</span><span class="s"> to Node instance.&quot;</span> <span class="o">%</span> <span class="n">obj</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The name of the node </span>
<span class="sd">        (only used for facilitating its identification in the user interface).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">relpath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the name of the Node.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Node identifier.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_id</span>

    <span class="k">def</span> <span class="nf">set_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the node identifier. Use it carefully!&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node_id</span> <span class="o">=</span> <span class="n">node_id</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">finalized</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if the `Node` has been finalized.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finalized</span>

    <span class="nd">@finalized.setter</span>
    <span class="k">def</span> <span class="nf">finalized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">boolean</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="n">boolean</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;Finalized&quot;</span><span class="p">)</span>

    <span class="c">#@property</span>
    <span class="c">#def str_history(self):</span>
    <span class="c">#    &quot;&quot;&quot;String representation of history.&quot;&quot;&quot;</span>
    <span class="c">#    return &quot;\n&quot;.join(self.history)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">corrections</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        List of dictionaries with infornation on the actions performed to solve `AbiCritical` Events.</span>
<span class="sd">        Each dictionary contains the `AbinitEvent` who triggered the correction and </span>
<span class="sd">        a human-readable message with the description of the operation performed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_corrections</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_file</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if this node is a file&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">FileNode</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_task</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if this node is a Task&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Task</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_work</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if this node is a Work&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.works</span> <span class="kn">import</span> <span class="n">Work</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Work</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_flow</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if this node is a Flow&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.flows</span> <span class="kn">import</span> <span class="n">Flow</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Flow</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_subnodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if self contains sub-nodes e.g. `Work` object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Iterable</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">deps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        List of `Dependency` objects defining the dependencies </span>
<span class="sd">        of this `Node`. Empty list if this `Node` does not have dependencies.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deps</span>

    <span class="k">def</span> <span class="nf">add_deps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a list of dependencies to the :class:`Node`.</span>

<span class="sd">        Args:</span>
<span class="sd">            deps: List of :class:`Dependency` objects specifying the dependencies of the node.</span>
<span class="sd">                  or dictionary mapping nodes to file extensions e.g. {task: &quot;DEN&quot;}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">deps</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Mapping</span><span class="p">):</span>
            <span class="c"># Convert dictionary into list of dependencies.</span>
            <span class="n">deps</span> <span class="o">=</span> <span class="p">[</span><span class="n">Dependency</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">exts</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">exts</span> <span class="ow">in</span> <span class="n">deps</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>

        <span class="c"># We want a list</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">deps</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">deps</span> <span class="o">=</span> <span class="p">[</span><span class="n">deps</span><span class="p">]</span>

        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">Dependency</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">deps</span><span class="p">)</span>

        <span class="c"># Add the dependencies to the node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_deps</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">deps</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_subnodes</span><span class="p">:</span>
            <span class="c"># This means that the node contains sub-nodes </span>
            <span class="c"># that should inherit the same dependency.</span>
            <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">task</span><span class="o">.</span><span class="n">add_deps</span><span class="p">(</span><span class="n">deps</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove_deps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove a list of dependencies from the :class:`Node`.</span>

<span class="sd">        Args:</span>
<span class="sd">            deps: List of :class:`Dependency` objects specifying the  dependencies of the node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">deps</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">deps</span> <span class="o">=</span> <span class="p">[</span><span class="n">deps</span><span class="p">]</span>

        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">Dependency</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">deps</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_deps</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deps</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">deps</span><span class="p">]</span>
                                                                                      
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_subnodes</span><span class="p">:</span>
            <span class="c"># This means that the node consists of sub-nodes </span>
            <span class="c"># that should remove the same list of dependencies.</span>
            <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">task</span><span class="o">.</span><span class="n">remove_deps</span><span class="p">(</span><span class="n">deps</span><span class="p">)</span>                                                                                                                                        

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">deps_status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list with the status of the dependencies.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">deps</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">]</span>
                                                                  
        <span class="k">return</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">status</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deps</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">depends_on</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if this node depends on the other node.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">other</span> <span class="ow">in</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">node</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deps</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">get_parents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the list of nodes in the :class:`Flow` required by this :class:`Node`&quot;&quot;&quot;</span>
        <span class="n">parents</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">work</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">depends_on</span><span class="p">(</span><span class="n">work</span><span class="p">):</span> <span class="n">parents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">work</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">work</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">depends_on</span><span class="p">(</span><span class="n">task</span><span class="p">):</span> <span class="n">parents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">parents</span>

    <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the list of nodes in the :class:`Flow` that depends on this :class:`Node`&quot;&quot;&quot;</span>
        <span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">work</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">work</span><span class="o">.</span><span class="n">depends_on</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">work</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">work</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">task</span><span class="o">.</span><span class="n">depends_on</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">children</span>

    <span class="k">def</span> <span class="nf">str_deps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the string representation of the dependencies of the node.&quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>

        <span class="n">app</span><span class="p">(</span><span class="s">&quot;Dependencies of node </span><span class="si">%s</span><span class="s">:&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dep</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deps</span><span class="p">):</span>
            <span class="n">app</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%d</span><span class="s">) </span><span class="si">%s</span><span class="s">, status=</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">dep</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">dep</span><span class="o">.</span><span class="n">status</span><span class="p">)))</span>

        <span class="k">return</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_cleanup_exts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exts</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the list of file extensions that should be removed when the task reaches S_OK.</span>

<span class="sd">            Args:</span>
<span class="sd">                exts: List of file extensions, if exts is None a default list is provided.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">exts</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="n">exts</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;WFK&quot;</span><span class="p">,</span> <span class="s">&quot;SUS&quot;</span><span class="p">,</span> <span class="s">&quot;SCR&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cleanup_exts</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">exts</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cleanup_exts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set of file extensions to remove.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cleanup_exts</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">set_user_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Store additional info provided by the user in self.user_info</span>

<span class="sd">        .. warning::</span>

<span class="sd">            The objects stored in the dict must support pickle.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;_user_info&quot;</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_info</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_user_info</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">user_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns an :class:`AttrDict` with the variables stored in self._user_info.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">AttrDict</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_user_info</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span>

    <span class="c">#@abc.abstractmethod</span>
    <span class="c">#def set_status(self, status, info_msg=None):</span>
    <span class="c">#    &quot;&quot;&quot;</span>
    <span class="c">#    Set and return the status of the None</span>
    <span class="c">#                                                                                     </span>
    <span class="c">#    Args:</span>
    <span class="c">#        status: Status object or string representation of the status</span>
    <span class="c">#        info_msg: string with human-readable message used in the case of errors (optional)</span>
    <span class="c">#    &quot;&quot;&quot;</span>

    <span class="nd">@abc.abstractproperty</span>
    <span class="k">def</span> <span class="nf">status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The status of the `Node`.&quot;&quot;&quot;</span>

    <span class="nd">@abc.abstractmethod</span>
    <span class="k">def</span> <span class="nf">check_status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check the status of the `Node`.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">FileNode</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Node that consists of a file. May be not yet existing</span>

<span class="sd">    Mainly used to connect :class:`Task` objects to external files produced in previous runs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FileNode</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

        <span class="c"># Directories with input|output|temporary data.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">workdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filepath</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">indir</span> <span class="o">=</span> <span class="n">Directory</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span> <span class="o">=</span> <span class="n">Directory</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tmpdir</span> <span class="o">=</span> <span class="n">Directory</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">products</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">Product</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filepath</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">opath_from_ext</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ext</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">filepath</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span> <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filepath</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span>

    <span class="k">def</span> <span class="nf">check_status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span>

    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">FileNode</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_results</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c">#results.register_gridfs_files(self.filepath=self.filepath)</span>
        <span class="k">return</span> <span class="n">results</span>


<span class="k">class</span> <span class="nc">TaskError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base Exception for `Task` methods&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">TaskRestartError</span><span class="p">(</span><span class="n">TaskError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Exception raised while trying to restart the `Task`.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">Task</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">with_metaclass</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span><span class="p">,</span> <span class="n">Node</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;A Task is a node that performs some kind of calculation.&quot;&quot;&quot;</span>
    <span class="c"># Use class attributes for TaskErrors so that we don&#39;t have to import them.</span>
    <span class="n">Error</span> <span class="o">=</span> <span class="n">TaskError</span>
    <span class="n">RestartError</span> <span class="o">=</span> <span class="n">TaskRestartError</span>

    <span class="c"># List of `AbinitEvent` subclasses that are tested in the not_converged method. </span>
    <span class="c"># Subclasses should provide their own list if they need to check the converge status.</span>
    <span class="n">CRITICAL_EVENTS</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">]</span>

    <span class="c"># Prefixes for Abinit (input, output, temporary) files.</span>
    <span class="n">Prefix</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s">&quot;Prefix&quot;</span><span class="p">,</span> <span class="s">&quot;idata odata tdata&quot;</span><span class="p">)</span>
    <span class="n">pj</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span>

    <span class="n">prefix</span> <span class="o">=</span> <span class="n">Prefix</span><span class="p">(</span><span class="n">pj</span><span class="p">(</span><span class="s">&quot;indata&quot;</span><span class="p">,</span> <span class="s">&quot;in&quot;</span><span class="p">),</span> <span class="n">pj</span><span class="p">(</span><span class="s">&quot;outdata&quot;</span><span class="p">,</span> <span class="s">&quot;out&quot;</span><span class="p">),</span> <span class="n">pj</span><span class="p">(</span><span class="s">&quot;tmpdata&quot;</span><span class="p">,</span> <span class="s">&quot;tmp&quot;</span><span class="p">))</span>
    <span class="k">del</span> <span class="n">Prefix</span><span class="p">,</span> <span class="n">pj</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strategy</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            strategy: Input file or :class:`Strategy` instance defining the calculation.</span>
<span class="sd">            workdir: Path to the working directory.</span>
<span class="sd">            manager: :class:`TaskManager` object.</span>
<span class="sd">            deps: Dictionary specifying the dependency of this node.</span>
<span class="sd">                  None means that this obj has no dependency.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Init the node</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Task</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>

        <span class="c"># Save the strategy to use to generate the input file.</span>
        <span class="c"># FIXME</span>
        <span class="c">#self.strategy = strategy.deepcopy()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span> <span class="o">=</span> <span class="n">strategy</span>
                                                               
        <span class="k">if</span> <span class="n">workdir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_workdir</span><span class="p">(</span><span class="n">workdir</span><span class="p">)</span>
                                                               
        <span class="k">if</span> <span class="n">manager</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_manager</span><span class="p">(</span><span class="n">manager</span><span class="p">)</span>

        <span class="c"># Handle possible dependencies.</span>
        <span class="k">if</span> <span class="n">deps</span><span class="p">:</span>
            <span class="n">deps</span> <span class="o">=</span> <span class="p">[</span><span class="n">Dependency</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">exts</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">exts</span><span class="p">)</span> <span class="ow">in</span> <span class="n">deps</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_deps</span><span class="p">(</span><span class="n">deps</span><span class="p">)</span>

        <span class="c"># Use to compute the wall-time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_datetime</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stop_datetime</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>

        <span class="c"># Count the number of restarts.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_restarts</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_qjob</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queue_errors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">abi_errors</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return state is pickled as the contents for the instance.</span>
<span class="sd">                                                                                      </span>
<span class="sd">        In this case we just remove the process since Subprocess objects cannot be pickled.</span>
<span class="sd">        This is the reason why we have to store the returncode in self._returncode instead</span>
<span class="sd">        of using self.process.returncode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;_process&quot;</span><span class="p">]}</span>

    <span class="k">def</span> <span class="nf">set_workdir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">workdir</span><span class="p">,</span> <span class="n">chroot</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the working directory. Cannot be set more than once unless chroot is True&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">chroot</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;workdir&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">workdir</span> <span class="o">!=</span> <span class="n">workdir</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;self.workdir != workdir: </span><span class="si">%s</span><span class="s">, </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span>  <span class="n">workdir</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">workdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">workdir</span><span class="p">)</span>

        <span class="c"># Files required for the execution.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;run.abi&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;run.abo&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">files_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;run.files&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">job_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;job.sh&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;run.log&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stderr_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;run.err&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_lockfile</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;__startlock__&quot;</span><span class="p">))</span>

        <span class="c"># Directories with input|output|temporary data.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indir</span> <span class="o">=</span> <span class="n">Directory</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;indata&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span> <span class="o">=</span> <span class="n">Directory</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;outdata&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tmpdir</span> <span class="o">=</span> <span class="n">Directory</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;tmpdata&quot;</span><span class="p">))</span>

        <span class="c"># stderr and output file of the queue manager. Note extensions.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qerr_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;queue.qerr&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qout_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;queue.qout&quot;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">set_manager</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">manager</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the :class:`TaskManager` to use to launch the Task.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">manager</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>

        <span class="c"># TODO</span>
        <span class="c"># Select adapters associated to the Task class</span>
        <span class="c">#keep = []</span>
        <span class="c">#for i, qad in enumerate(self.manager.qads):</span>
        <span class="c">#    if self.__class__.__name__ in qad.task_classes:</span>
        <span class="c">#        keep.append(i)</span>
        <span class="c">#if keep:</span>
        <span class="c">#    self._qads = [self._qads[i] for i in keep]</span>
        <span class="c">#    self._qadpos = 0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">work</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The :class:`Work` containing this `Task`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_work</span>

    <span class="k">def</span> <span class="nf">set_work</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the :class:`Work` associated to this `Task`.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;_work&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_work</span> <span class="o">=</span> <span class="n">work</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_work</span> <span class="o">!=</span> <span class="n">work</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;self._work != work&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">flow</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The :class:`Flow` containing this `Task`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">work</span><span class="o">.</span><span class="n">flow</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">pos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The position of the task in the :class:`Flow`&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">task</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">work</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">task</span><span class="p">:</span> 
                <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">work</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Cannot find the position of </span><span class="si">%s</span><span class="s"> in flow </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pos_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String representation of self.pos&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s">&quot;w&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s">&quot;_t&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_launches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of launches performed. This number includes both possible ABINIT restarts</span>
<span class="sd">        as well as possible launches done due to errors encountered with the resource manager</span>
<span class="sd">        or the hardware/software.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">num_launches</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">qads</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_inpvar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">varname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the value of the ABINIT variable varname, None if not present.&quot;&quot;&quot;</span> 
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="p">,</span> <span class="s">&quot;abinit_input&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">abinit_input</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">varname</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;get_var for HTC interface!&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">initial_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initial structure of the task.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="p">,</span> <span class="s">&quot;abinit_input&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">abinit_input</span><span class="o">.</span><span class="n">structure</span>
            <span class="c">#return self.strategy.abinit_input[0].structure</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">structure</span>

    <span class="k">def</span> <span class="nf">make_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">with_header</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct the input file of the calculation.&quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">make_input</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">with_header</span><span class="p">:</span> <span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">+</span> <span class="n">s</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">ipath_from_ext</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ext</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the path of the input file with extension ext.</span>
<span class="sd">        Use it when the file does not exist yet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">.</span><span class="n">idata</span> <span class="o">+</span> <span class="s">&quot;_&quot;</span> <span class="o">+</span> <span class="n">ext</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">opath_from_ext</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ext</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the path of the output file with extension ext.</span>
<span class="sd">        Use it when the file does not exist yet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">.</span><span class="n">odata</span> <span class="o">+</span> <span class="s">&quot;_&quot;</span> <span class="o">+</span> <span class="n">ext</span><span class="p">)</span>

    <span class="nd">@abc.abstractproperty</span>
    <span class="k">def</span> <span class="nf">executable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Path to the executable associated to the task (internally stored in self._executable).</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">set_executable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">executable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the executable associate to this task.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_executable</span> <span class="o">=</span> <span class="n">executable</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c"># Attach a fake process so that we can poll it.</span>
            <span class="k">return</span> <span class="n">FakeProcess</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_completed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if the task has been executed.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_DONE</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">can_run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The task can run if its status is &lt; S_SUB and all the other dependencies (if any) are done!&quot;&quot;&quot;</span>
        <span class="n">all_ok</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="n">stat</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span> <span class="k">for</span> <span class="n">stat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deps_status</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_SUB</span> <span class="ow">and</span> <span class="n">all_ok</span>

    <span class="k">def</span> <span class="nf">not_converged</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if the calculation is not converged.&quot;&quot;&quot;</span>
        <span class="n">report</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_event_report</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">report</span><span class="o">.</span><span class="n">filter_types</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CRITICAL_EVENTS</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">run_etime</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        String with the wall-time</span>

<span class="sd">        ...note::</span>

<span class="sd">            The clock starts when self.status becomes S_RUN.</span>
<span class="sd">            thus run_etime does not correspond to the effective wall-time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># FIXME: This does not work as expected!</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;None&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_datetime</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stop_datetime</span>
            <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>

            <span class="c"># Compute time-delta, convert to string and remove microseconds (in any)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">stop</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_datetime</span><span class="p">)</span>
            <span class="n">microsec</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">microsec</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">[:</span><span class="n">microsec</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">cancel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cancel the job. Returns 1 if job was cancelled.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue_id</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span> 
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_DONE</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span> 

        <span class="n">exit_status</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">cancel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue_id</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">exit_status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>

        <span class="c"># Remove output files and reset the status.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_on_done</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fix_ofiles</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_on_ok</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># Read timing data.</span>
        <span class="c">#self.read_timing()</span>
        <span class="c"># Fix output file names.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fix_ofiles</span><span class="p">()</span>
        <span class="c"># Get results</span>
        <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_ok</span><span class="p">()</span>
        <span class="c"># Set internal flag.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="k">return</span> <span class="n">results</span>

    <span class="k">def</span> <span class="nf">on_ok</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called once the `Task` has reached status S_OK. </span>
<span class="sd">        Subclasses should provide their own implementation</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dictionary that must contain at least the following entries:</span>
<span class="sd">                returncode:</span>
<span class="sd">                    0 on success. </span>
<span class="sd">                message: </span>
<span class="sd">                    a string that should provide a human-readable description of what has been performed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">returncode</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s">&quot;Calling on_all_ok of the base class!&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fix_ofiles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called when the task reaches S_OK.</span>
<span class="sd">        It changes the extension of particular output files</span>
<span class="sd">        produced by Abinit so that the &#39;official&#39; extension</span>
<span class="sd">        is preserved e.g. out_1WF14 --&gt; out_1WF</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filepaths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">list_filepaths</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;in fix_ofiles with filepaths </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">filepaths</span><span class="p">)</span> 

        <span class="n">old2new</span> <span class="o">=</span> <span class="n">FilepathFixer</span><span class="p">()</span><span class="o">.</span><span class="n">fix_paths</span><span class="p">(</span><span class="n">filepaths</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span> <span class="ow">in</span> <span class="n">old2new</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;will rename old </span><span class="si">%s</span><span class="s"> to new </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">))</span>
            <span class="n">os</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_restart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">submit</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called by restart once we have finished preparing the task for restarting.</span>

<span class="sd">        Return: </span>
<span class="sd">            True if task has been restarted</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_READY</span><span class="p">,</span> <span class="n">info_msg</span><span class="o">=</span><span class="s">&quot;Restarted on </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">time</span><span class="o">.</span><span class="n">asctime</span><span class="p">())</span>

        <span class="c"># Increase the counter.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_restarts</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;Restarted with num_restarts </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_restarts</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">submit</span><span class="p">:</span>
            <span class="c"># Remove the lock file</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">start_lockfile</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
            <span class="c"># Relaunch the task.</span>
            <span class="n">fired</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">fired</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;restart failed&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fired</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">return</span> <span class="n">fired</span>

    <span class="k">def</span> <span class="nf">restart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Restart the calculation.  Subclasses should provide a concrete version that </span>
<span class="sd">        performs all the actions needed for preparing the restart and then calls self._restart</span>
<span class="sd">        to restart the task. The default implementation is empty.</span>

<span class="sd">        Returns:</span>
<span class="sd">            1 if job was restarted, 0 otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;Calling the **empty** restart method of the base class&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">poll</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if child process has terminated. Set and return returncode attribute.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_returncode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">poll</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_returncode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_DONE</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_returncode</span>

    <span class="k">def</span> <span class="nf">wait</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Wait for child process to terminate. Set and return returncode attribute.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_returncode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_DONE</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_returncode</span>

    <span class="k">def</span> <span class="nf">communicate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interact with process: Send data to stdin. Read data from stdout and stderr, until end-of-file is reached. </span>
<span class="sd">        Wait for process to terminate. The optional input argument should be a string to be sent to the </span>
<span class="sd">        child process, or None, if no data should be sent to the child.</span>

<span class="sd">        communicate() returns a tuple (stdoutdata, stderrdata).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stdoutdata</span><span class="p">,</span> <span class="n">stderrdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">communicate</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="nb">input</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_returncode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">returncode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_DONE</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">stdoutdata</span><span class="p">,</span> <span class="n">stderrdata</span> 

    <span class="k">def</span> <span class="nf">kill</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Kill the child.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_returncode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">returncode</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">returncode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The child return code, set by poll() and wait() (and indirectly by communicate()). </span>
<span class="sd">        A None value indicates that the process hasn&#39;t terminated yet.</span>
<span class="sd">        A negative value -N indicates that the child was terminated by signal N (Unix only).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span> 
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_returncode</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reset the task status. Mainly used if we made a silly mistake in the initial</span>
<span class="sd">        setup of the queue manager and we want to fix it and rerun the task.</span>

<span class="sd">        Returns:</span>
<span class="sd">            0 on success, 1 if reset failed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Can only reset tasks that are done.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_DONE</span><span class="p">:</span> <span class="k">return</span> <span class="mi">1</span>

        <span class="c"># Remove output files otherwise the EventParser will think the job is still running</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_file</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stderr_file</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_lockfile</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qerr_file</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qout_file</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_INIT</span><span class="p">,</span> <span class="n">info_msg</span><span class="o">=</span><span class="s">&quot;Reset on </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">time</span><span class="o">.</span><span class="n">asctime</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_qjob</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>

        <span class="c"># TODO send a signal to the flow </span>
        <span class="c">#self.work.check_status()</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="nd">@return_none_if_raise</span><span class="p">(</span><span class="ne">AttributeError</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">queue_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Queue identifier returned by the Queue manager. None if not set&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qjob</span><span class="o">.</span><span class="n">qid</span>

    <span class="nd">@property</span>
    <span class="nd">@return_none_if_raise</span><span class="p">(</span><span class="ne">AttributeError</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">qname</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Queue name identifier returned by the Queue manager. None if not set&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qjob</span><span class="o">.</span><span class="n">qname</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">qjob</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qjob</span>

    <span class="k">def</span> <span class="nf">set_qjob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qjob</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set info on queue after submission.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qjob</span> <span class="o">=</span> <span class="n">qjob</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if we are submitting jobs via a queue manager.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">QTYPE</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="s">&quot;shell&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_cores</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Total number of CPUs used to run the task.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">num_cores</span>
                                                         
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mpi_procs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of CPUs used for MPI.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">mpi_procs</span>
                                                         
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">omp_threads</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of CPUs used for OpenMP.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">omp_threads</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mem_per_proc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Memory per MPI process.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Memory</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">mem_per_proc</span><span class="p">,</span> <span class="s">&quot;Mb&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gives the status of the task.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_status</span>

    <span class="k">def</span> <span class="nf">set_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">info_msg</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set and return the status of the task.</span>

<span class="sd">        Args:</span>
<span class="sd">            status: Status object or string representation of the status</span>
<span class="sd">            info_msg: string with human-readable message used in the case of errors (optional)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">Status</span><span class="o">.</span><span class="n">as_status</span><span class="p">(</span><span class="n">status</span><span class="p">)</span>

        <span class="n">changed</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;_status&quot;</span><span class="p">):</span>
            <span class="n">changed</span> <span class="o">=</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_status</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_status</span> <span class="o">=</span> <span class="n">status</span>

        <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_RUN</span><span class="p">:</span>
            <span class="c"># Set start_datetime when the task enters S_RUN</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_datetime</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">start_datetime</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>

        <span class="c"># Add new entry to history only if the status has changed.</span>
        <span class="k">if</span> <span class="n">changed</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_SUB</span><span class="p">:</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">_submission_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;Submitted with: MPI=</span><span class="si">%s</span><span class="s">, Omp=</span><span class="si">%s</span><span class="s">, Memproc=</span><span class="si">%.1f</span><span class="s"> [Gb]&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mpi_procs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">omp_threads</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mem_per_proc</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s">&quot;Gb&quot;</span><span class="p">)))</span>

            <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;Completed&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_ABICRITICAL</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;Set status to S_ABI_CRITICAL.</span><span class="se">\n</span><span class="s">Error:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">info_msg</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_DONE</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stop_datetime</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>

            <span class="c"># Execute the callback</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_on_done</span><span class="p">()</span>
                                                                                
        <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">:</span>
            <span class="c"># Finalize the task.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">finalized</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_on_ok</span><span class="p">()</span>
                <span class="c"># here we remove the output files of the task and of its parents.</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cleanup_exts</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">clean_output_files</span><span class="p">()</span>
                                                                                
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;Task </span><span class="si">%s</span><span class="s"> broadcasts signal S_OK&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
            <span class="n">dispatcher</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">signal</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">,</span> <span class="n">sender</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">status</span>

    <span class="k">def</span> <span class="nf">check_status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function checks the status of the task by inspecting the output and the</span>
<span class="sd">        error files produced by the application and by the queue manager.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># 1) see it the job is blocked</span>
        <span class="c"># 2) see if an error occured at submitting the job the job was submitted, TODO these problems can be solved</span>
        <span class="c"># 3) see if there is output</span>
        <span class="c"># 4) see if abinit reports problems</span>
        <span class="c"># 5) see if both err files exist and are empty</span>
        <span class="c"># 6) no output and no err files, the job must still be running</span>
        <span class="c"># 7) try to find out what caused the problems</span>
        <span class="c"># 8) there is a problem but we did not figure out what ...</span>
        <span class="c"># 9) the only way of landing here is if there is a output file but no err files...</span>

        <span class="c"># 1) A locked task can only be unlocked by calling set_status explicitly.</span>
        <span class="c"># an errored task, should not end up here but just to be sure</span>
        <span class="n">black_list</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_LOCKED</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="ow">in</span> <span class="n">black_list</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span>

        <span class="c"># 2) Check the returncode of the process (the process of submitting the job) first.</span>
        <span class="c"># this point type of problem should also be handled by the scheduler error parser</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">returncode</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c"># The job was not submitter properly</span>
            <span class="n">info_msg</span> <span class="o">=</span> <span class="s">&quot;return code </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">returncode</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_QCRITICAL</span><span class="p">,</span> <span class="n">info_msg</span><span class="o">=</span><span class="n">info_msg</span><span class="p">)</span>           

        <span class="c"># Analyze the stderr file for Fortran runtime errors.</span>
        <span class="n">err_msg</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stderr_file</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
            <span class="n">err_msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stderr_file</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

        <span class="c"># Analyze the stderr file of the resource manager runtime errors.</span>
        <span class="n">err_info</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">qerr_file</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
            <span class="n">err_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qerr_file</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

        <span class="c"># Start to check ABINIT status if the output file has been created.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">report</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_event_report</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="n">info_msg</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> exception while parsing event_report:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="n">info_msg</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ABICRITICAL</span><span class="p">,</span> <span class="n">info_msg</span><span class="o">=</span><span class="n">info_msg</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">report</span><span class="o">.</span><span class="n">run_completed</span><span class="p">:</span>
                <span class="c"># Check if the calculation converged.</span>
                <span class="n">not_ok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">not_converged</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">not_ok</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_UNCONVERGED</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">)</span>

            <span class="c"># Calculation still running or errors?</span>
            <span class="k">if</span> <span class="n">report</span><span class="o">.</span><span class="n">errors</span> <span class="ow">or</span> <span class="n">report</span><span class="o">.</span><span class="n">bugs</span><span class="p">:</span>
                <span class="c"># Abinit reported problems</span>
                <span class="k">if</span> <span class="n">report</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&#39;Found errors in report&#39;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">error</span> <span class="ow">in</span> <span class="n">report</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">abi_errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">abi_errors</span> <span class="o">=</span> <span class="p">[</span><span class="n">error</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">report</span><span class="o">.</span><span class="n">bugs</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&#39;Found bugs in report:&#39;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">bug</span> <span class="ow">in</span> <span class="n">report</span><span class="o">.</span><span class="n">bugs</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">bug</span><span class="p">))</span>

                <span class="c"># The job is unfixable due to ABINIT errors</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">: Found Errors or Bugs in ABINIT main output!&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
                <span class="n">info_msg</span> <span class="o">=</span> <span class="s">&quot;[&quot;</span><span class="o">+</span><span class="s">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">report</span><span class="o">.</span><span class="n">errors</span><span class="p">))</span><span class="o">+</span><span class="s">&quot;]&quot;</span> <span class="o">+</span> <span class="s">&quot;[&quot;</span><span class="o">+</span><span class="s">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">report</span><span class="o">.</span><span class="n">bugs</span><span class="p">))</span><span class="o">+</span><span class="s">&quot;]&quot;</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ABICRITICAL</span><span class="p">,</span> <span class="n">info_msg</span><span class="o">=</span><span class="n">info_msg</span><span class="p">)</span>


            <span class="c"># 5)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stderr_file</span><span class="o">.</span><span class="n">exists</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">err_info</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">qerr_file</span><span class="o">.</span><span class="n">exists</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">err_msg</span><span class="p">:</span>
                    <span class="c"># there is output and no errors</span>
                    <span class="c"># The job still seems to be running</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_RUN</span><span class="p">)</span>

        <span class="c"># 6)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;output_file does not exists&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">stderr_file</span><span class="o">.</span><span class="n">exists</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">qerr_file</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>     
                <span class="c"># No output at allThe job is still in the queue.</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span>
                
        <span class="c"># 7) Analyze the files of the resource manager and abinit and execution err (mvs)</span>
        <span class="k">if</span> <span class="n">err_info</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">pymatgen.io.abinitio.scheduler_error_parsers</span> <span class="kn">import</span> <span class="n">get_parser</span>
            <span class="n">scheduler_parser</span> <span class="o">=</span> <span class="n">get_parser</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">QTYPE</span><span class="p">,</span> <span class="n">err_file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qerr_file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
                                          <span class="n">out_file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qout_file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">run_err_file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stderr_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">scheduler_parser</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_QCRITICAL</span><span class="p">,</span> 
                                      <span class="n">info_msg</span><span class="o">=</span><span class="s">&quot;Cannot find scheduler_parser for qtype </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">QTYPE</span><span class="p">)</span>
                
            <span class="n">scheduler_parser</span><span class="o">.</span><span class="n">parse</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">scheduler_parser</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span>
                <span class="c"># the queue errors in the task</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&#39;scheduler errors found:&#39;</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">scheduler_parser</span><span class="o">.</span><span class="n">errors</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">queue_errors</span> <span class="o">=</span> <span class="n">scheduler_parser</span><span class="o">.</span><span class="n">errors</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_QCRITICAL</span><span class="p">)</span>
                <span class="c"># The job is killed or crashed and we know what happened</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">err_info</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&#39;found unknown queue error: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">err_info</span><span class="p">))</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_QCRITICAL</span><span class="p">,</span> <span class="n">info_msg</span><span class="o">=</span><span class="n">err_info</span><span class="p">)</span>
                    <span class="c"># The job is killed or crashed but we don&#39;t know what happened</span>
                    <span class="c"># it is set to QCritical, we will attempt to fix it by running on more resources</span>

        <span class="c"># 8) analizing the err files and abinit output did not identify a problem</span>
        <span class="c"># but if the files are not empty we do have a problem but no way of solving it:</span>
        <span class="k">if</span> <span class="n">err_msg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&#39;found error message:</span><span class="se">\n</span><span class="s"> </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">err_msg</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_QCRITICAL</span><span class="p">,</span> <span class="n">info_msg</span><span class="o">=</span><span class="n">err_info</span><span class="p">)</span>
            <span class="c"># The job is killed or crashed but we don&#39;t know what happend</span>
            <span class="c"># it is set to QCritical, we will attempt to fix it by running on more resources</span>

        <span class="c"># 9) if we still haven&#39;t returned there is no indication of any error and the job can only still be running</span>
        <span class="c"># but we should actually never land here, or we have delays in the file system ....</span>
        <span class="c"># print(&#39;the job still seems to be running maybe it is hanging without producing output... &#39;)</span>

        <span class="c"># Check time of last modification.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">exists</span> <span class="ow">and</span> \
           <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">get_stat</span><span class="p">()</span><span class="o">.</span><span class="n">st_mtime</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">policy</span><span class="o">.</span><span class="n">frozen_timeout</span><span class="p">):</span>
            <span class="n">info_msg</span> <span class="o">=</span> <span class="s">&quot;Task seems to be frozen, last modif more than </span><span class="si">%s</span><span class="s"> [s] ago&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">policy</span><span class="o">.</span><span class="n">frozen_timeout</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">info_msg</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_RUN</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reduce_memory_demand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method that can be called by the flow to decrease the memory demand of a specific task.</span>
<span class="sd">        Returns True in case of success, False in case of Failure.</span>
<span class="sd">        Should be overwritten by specific tasks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">speed_up</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method that can be called by the flow to decrease the time needed for a specific task.</span>
<span class="sd">        Returns True in case of success, False in case of Failure</span>
<span class="sd">        Should be overwritten by specific tasks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">out_to_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Move an output file to the output data directory of the `Task` </span>
<span class="sd">        and rename the file so that ABINIT will read it as an input data file.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The absolute path of the new file in the indata directory.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">in_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">out_file</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&quot;out&quot;</span><span class="p">,</span> <span class="s">&quot;in&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">dest</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indir</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">in_file</span><span class="p">)</span>
                                                                           
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">islink</span><span class="p">(</span><span class="n">dest</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&quot;Will overwrite </span><span class="si">%s</span><span class="s"> with </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">out_file</span><span class="p">))</span>
                                                                           
        <span class="n">os</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">out_file</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dest</span>

    <span class="k">def</span> <span class="nf">inlink_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a symbolic link to the specified file in the </span>
<span class="sd">        directory containing the input files of the task.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filepath</span><span class="p">):</span> 
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;Creating symbolic link to not existent file </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">filepath</span><span class="p">)</span>

        <span class="c"># Extract the Abinit extension and add the prefix for input files.</span>
        <span class="n">root</span><span class="p">,</span> <span class="n">abiext</span> <span class="o">=</span> <span class="n">abi_splitext</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>

        <span class="n">infile</span> <span class="o">=</span> <span class="s">&quot;in_&quot;</span> <span class="o">+</span> <span class="n">abiext</span>
        <span class="n">infile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indir</span><span class="o">.</span><span class="n">path_in</span><span class="p">(</span><span class="n">infile</span><span class="p">)</span>

        <span class="c"># Link path to dest if dest link does not exist.</span>
        <span class="c"># else check that it points to the expected file.</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;Linking path </span><span class="si">%s</span><span class="s"> --&gt; </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">infile</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">infile</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">symlink</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">infile</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="n">infile</span><span class="p">)</span> <span class="o">!=</span> <span class="n">filepath</span><span class="p">:</span>
                <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s">&quot;infile </span><span class="si">%s</span><span class="s"> does not point to filepath </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">infile</span><span class="p">,</span> <span class="n">filepath</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">make_links</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create symbolic links to the output files produced by the other tasks.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            </span>
<span class="sd">            This method should be called only when the calculation is READY because</span>
<span class="sd">            it uses a heuristic approach to find the file to link.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">dep</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deps</span><span class="p">:</span>
            <span class="n">filepaths</span><span class="p">,</span> <span class="n">exts</span> <span class="o">=</span> <span class="n">dep</span><span class="o">.</span><span class="n">get_filepaths_and_exts</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">path</span><span class="p">,</span> <span class="n">ext</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">filepaths</span><span class="p">,</span> <span class="n">exts</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Need path </span><span class="si">%s</span><span class="s"> with ext </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">ext</span><span class="p">))</span>
                <span class="n">dest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ipath_from_ext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span> 
                    <span class="c"># Try netcdf file. TODO: this case should be treated in a cleaner way.</span>
                    <span class="n">path</span> <span class="o">+=</span> <span class="s">&quot;-etsf.nc&quot;</span>
                    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span> <span class="n">dest</span> <span class="o">+=</span> <span class="s">&quot;-etsf.nc&quot;</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
                    <span class="n">err_msg</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">: </span><span class="si">%s</span><span class="s"> is needed by this task but it does not exist&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>

                <span class="c"># Link path to dest if dest link does not exist.</span>
                <span class="c"># else check that it points to the expected file.</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;Linking path </span><span class="si">%s</span><span class="s"> --&gt; </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">dest</span><span class="p">))</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">dest</span><span class="p">):</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">symlink</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span> <span class="o">!=</span> <span class="n">path</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s">&quot;dest </span><span class="si">%s</span><span class="s"> does not point to path </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">path</span><span class="p">))</span>

    <span class="nd">@abc.abstractmethod</span>
    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Public method called before submitting the task.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method calls self.setup after having performed additional operations</span>
<span class="sd">        such as the creation of the symbolic links needed to connect different tasks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">make_links</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setup</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_event_report</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s">&quot;log&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Analyzes the main output file for possible Errors or Warnings.</span>

<span class="sd">        Args:</span>
<span class="sd">            source: &quot;output&quot; for the main output file,&quot;log&quot; for the log file.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`EventReport` instance or None if the main output file does not exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># TODO: For the time being, we inspect the log file,</span>
        <span class="c"># We will start to use the output file when the migration to YAML is completed</span>
        <span class="n">ofile</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s">&quot;output&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="p">,</span>
            <span class="s">&quot;log&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_file</span><span class="p">}[</span><span class="n">source</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">ofile</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="c"># Don&#39;t parse source file if we already have its report and the source didn&#39;t change.</span>
        <span class="c">#if not hasattr(self, &quot;_prev_reports&quot;): self._prev_reports = {}</span>
        <span class="c">#old_report = self._prev_reports.get(source, None)</span>
        <span class="c">#if False and old_report is not None and old_report.stat.st_mtime == ofile.get_stat().st_mtime:</span>
        <span class="c">#    print(&quot;Returning old_report&quot;)</span>
        <span class="c">#    return old_report</span>

        <span class="n">parser</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">EventsParser</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">report</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">ofile</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
            <span class="c">#self._prev_reports[source] = report</span>
            <span class="k">return</span> <span class="n">report</span>

        <span class="k">except</span> <span class="n">parser</span><span class="o">.</span><span class="n">Error</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="c"># Return a report with an error entry with info on the exception.</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">: Exception while parsing ABINIT events:</span><span class="se">\n</span><span class="s"> </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ofile</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ABICRITICAL</span><span class="p">,</span> <span class="n">info_msg</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">parser</span><span class="o">.</span><span class="n">report_exception</span><span class="p">(</span><span class="n">ofile</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">exc</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns :class:`NodeResults` instance.</span>
<span class="sd">        Subclasses should extend this method (if needed) by adding </span>
<span class="sd">        specialized code that performs some kind of post-processing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Check whether the process completed.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">returncode</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s">&quot;return code is None, you should call wait, communitate or poll&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_DONE</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s">&quot;Task is not completed&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Results</span><span class="o">.</span><span class="n">from_node</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">is_abspath</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recursively move self.workdir to another location. This is similar to the Unix &quot;mv&quot; command.</span>
<span class="sd">        The destination path must not already exist. If the destination already exists</span>
<span class="sd">        but is not a directory, it may be overwritten depending on os.rename() semantics.</span>

<span class="sd">        Be default, dest is located in the parent directory of self.workdir.</span>
<span class="sd">        Use is_abspath=True to specify an absolute path.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_abspath</span><span class="p">:</span>
            <span class="n">dest</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">),</span> <span class="n">dest</span><span class="p">)</span>

        <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">in_files</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return all the input data files used.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">indir</span><span class="o">.</span><span class="n">list_filepaths</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">out_files</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return all the output data files produced.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">list_filepaths</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">tmp_files</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return all the input data files produced.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmpdir</span><span class="o">.</span><span class="n">list_filepaths</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">path_in_workdir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create the absolute path of filename in the top-level working directory.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_basename</span><span class="p">,</span> <span class="n">dest_basename</span><span class="p">,</span> <span class="n">datadir</span><span class="o">=</span><span class="s">&quot;outdir&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rename a file located in datadir.</span>

<span class="sd">        src_basename and dest_basename are the basename of the source file</span>
<span class="sd">        and of the destination file, respectively.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">directory</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s">&quot;indir&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">indir</span><span class="p">,</span>
            <span class="s">&quot;outdir&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="p">,</span>
            <span class="s">&quot;tmpdir&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmpdir</span><span class="p">,</span>
        <span class="p">}[</span><span class="n">datadir</span><span class="p">]</span>

        <span class="n">src</span> <span class="o">=</span> <span class="n">directory</span><span class="o">.</span><span class="n">path_in</span><span class="p">(</span><span class="n">src_basename</span><span class="p">)</span>
        <span class="n">dest</span> <span class="o">=</span> <span class="n">directory</span><span class="o">.</span><span class="n">path_in</span><span class="p">(</span><span class="n">dest_basename</span><span class="p">)</span>

        <span class="n">os</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates the working directory and the input files of the :class:`Task`.</span>
<span class="sd">        It does not overwrite files if they already exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Create dirs for input, output and tmp data.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indir</span><span class="o">.</span><span class="n">makedirs</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">makedirs</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tmpdir</span><span class="o">.</span><span class="n">makedirs</span><span class="p">()</span>

        <span class="c"># Write files file and input file.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">files_file</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">files_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filesfile_string</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">input_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">make_input</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">write_jobfile</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rmtree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exclude_wildcard</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all files and directories in the working directory</span>

<span class="sd">        Args:</span>
<span class="sd">            exclude_wildcard: Optional string with regular expressions separated by |.</span>
<span class="sd">                Files matching one of the regular expressions will be preserved.</span>
<span class="sd">                example: exclude_wildcard=&quot;*.nc|*.txt&quot; preserves all the files whose extension is in [&quot;nc&quot;, &quot;txt&quot;].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">exclude_wildcard</span><span class="p">:</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">WildCard</span><span class="p">(</span><span class="n">exclude_wildcard</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">dirpath</span><span class="p">,</span> <span class="n">dirnames</span><span class="p">,</span> <span class="n">filenames</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">:</span>
                    <span class="n">filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirpath</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">w</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">filenames</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove all the files listed in filenames.&quot;&quot;&quot;</span>
        <span class="n">filenames</span> <span class="o">=</span> <span class="n">list_strings</span><span class="p">(</span><span class="n">filenames</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">dirpath</span><span class="p">,</span> <span class="n">dirnames</span><span class="p">,</span> <span class="n">fnames</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">fnames</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">:</span>
                    <span class="n">filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirpath</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">clean_output_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">follow_parents</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called when the task reaches S_OK. It removes all the output files </span>
<span class="sd">        produced by the task that are not needed by its children as well as the output files</span>
<span class="sd">        produced by its parents if no other node needs them.</span>

<span class="sd">        Args:</span>
<span class="sd">            follow_parents: If true, the output files of the parents nodes will be removed if possible.</span>
<span class="sd">            </span>
<span class="sd">        Return:</span>
<span class="sd">            list with the absolute paths of the files that have been removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&quot;Calling task.clean_output_files on a task whose status != S_OK&quot;</span><span class="p">)</span>

        <span class="c"># Remove all files in tmpdir.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tmpdir</span><span class="o">.</span><span class="n">clean</span><span class="p">()</span>

        <span class="c"># Find the file extensions that should be preserved since these files are still </span>
        <span class="c"># needed by the children who haven&#39;t reached S_OK</span>
        <span class="n">except_exts</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_children</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">:</span> <span class="k">continue</span>
            <span class="c"># Find the position of self in child.deps and add the extensions.</span>
            <span class="n">i</span> <span class="o">=</span> <span class="p">[</span><span class="n">dep</span><span class="o">.</span><span class="n">node</span> <span class="k">for</span> <span class="n">dep</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">deps</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> 
            <span class="n">except_exts</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">deps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">exts</span><span class="p">)</span>

        <span class="c"># Remove the files in the outdir of the task but keep except_exts. </span>
        <span class="n">exts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cleanup_exts</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">except_exts</span><span class="p">)</span>
        <span class="c">#print(&quot;Will remove its extensions: &quot;, exts)</span>
        <span class="n">paths</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">remove_exts</span><span class="p">(</span><span class="n">exts</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">follow_parents</span><span class="p">:</span> <span class="k">return</span> <span class="n">paths</span>

        <span class="c"># Remove the files in the outdir of my parents if all the possible dependencies have been fulfilled.</span>
        <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parents</span><span class="p">():</span>

            <span class="c"># Here we build a dictionary file extension --&gt; list of child nodes requiring this file from parent</span>
            <span class="c"># e.g {&quot;WFK&quot;: [node1, node2]}</span>
            <span class="n">ext2nodes</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">get_children</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">child</span><span class="o">.</span><span class="n">S_OK</span><span class="p">:</span> <span class="k">continue</span>
                <span class="n">i</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">node</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">deps</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">deps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">exts</span><span class="p">:</span>
                    <span class="n">ext2nodes</span><span class="p">[</span><span class="n">ext</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        
            <span class="c"># Remove extension only if no node depends on it!</span>
            <span class="n">except_exts</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">lst</span> <span class="ow">in</span> <span class="n">ext2nodes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">lst</span><span class="p">]</span>
            <span class="n">exts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cleanup_exts</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">except_exts</span><span class="p">)</span>
            <span class="c">#print(&quot;%s removes extensions %s from parent node %s&quot; % (self, exts, parent))</span>
            <span class="n">paths</span> <span class="o">+=</span> <span class="n">parent</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">remove_exts</span><span class="p">(</span><span class="n">exts</span><span class="p">)</span>

        <span class="c">#print(&quot;%s:\n Files removed: %s&quot; % (self, paths))</span>
        <span class="k">return</span> <span class="n">paths</span>

    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Base class does not provide any hook.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Starts the calculation by performing the following steps:</span>

<span class="sd">            - build dirs and files</span>
<span class="sd">            - call the _setup method</span>
<span class="sd">            - execute the job file by executing/submitting the job script.</span>

<span class="sd">        ==============  ==============================================================</span>
<span class="sd">        kwargs          Meaning</span>
<span class="sd">        ==============  ==============================================================</span>
<span class="sd">        autoparal       False to skip the autoparal step (default True)</span>
<span class="sd">        ==============  ==============================================================</span>

<span class="sd">        Returns:</span>
<span class="sd">            1 if task was started, 0 otherwise.</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_SUB</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s">&quot;Task status: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">status</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_lockfile</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&quot;Found lock file: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_lockfile</span><span class="o">.</span><span class="n">relpath</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">start_lockfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;Started on </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">time</span><span class="o">.</span><span class="n">asctime</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup</span><span class="p">()</span>

        <span class="c"># Add the variables needed to connect the node.</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deps</span><span class="p">:</span>
            <span class="n">cvars</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">connecting_vars</span><span class="p">()</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;Adding connecting vars </span><span class="si">%s</span><span class="s"> &quot;</span> <span class="o">%</span> <span class="n">cvars</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">add_extra_abivars</span><span class="p">(</span><span class="n">cvars</span><span class="p">)</span>

        <span class="c"># Automatic parallelization</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;autoparal&quot;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;autoparal_run&quot;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">autoparal_run</span><span class="p">()</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;autoparal_fake_run raised:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">straceback</span><span class="p">())</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ABICRITICAL</span><span class="p">)</span>
                <span class="k">return</span> <span class="mi">0</span>

        <span class="c"># Start the calculation in a subprocess and return.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">launch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">start_and_wait</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper method to start the task and wait for completetion.</span>

<span class="sd">        Mainly used when we are submitting the task via the shell without passing through a queue manager.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">retcode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">retcode</span>

    <span class="k">def</span> <span class="nf">as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;@module&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__module__</span><span class="p">,</span>
             <span class="s">&quot;@class&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">}</span>
        <span class="n">d</span><span class="p">[</span><span class="s">&#39;strategy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span>
        <span class="n">d</span><span class="p">[</span><span class="s">&#39;workdir&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;workdir&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;manager&#39;</span><span class="p">):</span>
            <span class="n">d</span><span class="p">[</span><span class="s">&#39;manager&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s">&#39;manager&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="n">dec</span> <span class="o">=</span> <span class="n">MontyDecoder</span><span class="p">()</span>
        <span class="n">strategy</span> <span class="o">=</span> <span class="n">dec</span><span class="o">.</span><span class="n">process_decoded</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s">&#39;strategy&#39;</span><span class="p">])</span>
        <span class="n">manager</span> <span class="o">=</span> <span class="n">TaskManager</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s">&#39;manager&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">strategy</span><span class="o">=</span><span class="n">strategy</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s">&#39;workdir&#39;</span><span class="p">],</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">AbinitTask</span><span class="p">(</span><span class="n">Task</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class defining an ABINIT calculation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Results</span> <span class="o">=</span> <span class="n">TaskResults</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_input</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">ainput</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an instance of `AbinitTask` from an ABINIT input.</span>
<span class="sd">    </span>
<span class="sd">        Args:</span>
<span class="sd">            ainput: `AbinitInput` object.</span>
<span class="sd">            workdir: Path to the working directory.</span>
<span class="sd">            manager: :class:`TaskManager` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># TODO: Find a better way to do this. I will likely need to refactor the Strategy object</span>
        <span class="n">strategy</span> <span class="o">=</span> <span class="n">StrategyWithInput</span><span class="p">(</span><span class="n">ainput</span><span class="p">,</span> <span class="n">deepcopy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">strategy</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abinit has the very *bad* habit of changing the file extension by appending the characters in [A,B ..., Z] </span>
<span class="sd">        to the output file, and this breaks a lot of code that relies of the use of a unique file extension.</span>
<span class="sd">        Here we fix this issue by renaming run.abo to run.abo_[number] if the output file &quot;run.abo&quot; already</span>
<span class="sd">        exists. A few lines of code in python, a lot of problems if you try to implement this trick in Fortran90. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
            <span class="c"># Find the index of the last file (if any) and push.</span>
            <span class="c"># TODO: Maybe it&#39;s better to use run.abo --&gt; run(1).abo</span>
            <span class="n">fnames</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">)</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">basename</span><span class="p">)]</span>
            <span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;_&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fnames</span><span class="p">]</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()]</span>
            <span class="n">last</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="k">if</span> <span class="n">nums</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="n">new_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span> <span class="o">+</span> <span class="s">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">last</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Will rename </span><span class="si">%s</span><span class="s"> to </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">new_path</span><span class="p">))</span>
            <span class="n">os</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">new_path</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">executable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Path to the executable required for running the Task.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_executable</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;abinit&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pseudos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List of pseudos used in the calculation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">pseudos</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">isnc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if norm-conserving calculation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">isnc</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ispaw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if PAW calculation&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">ispaw</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">filesfile_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String with the list of files and prefixes needed to execute ABINIT.&quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>
        <span class="n">pj</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span>

        <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>                 <span class="c"># Path to the input file</span>
        <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>                <span class="c"># Path to the output file</span>
        <span class="n">app</span><span class="p">(</span><span class="n">pj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">.</span><span class="n">idata</span><span class="p">))</span>  <span class="c"># Prefix for input data</span>
        <span class="n">app</span><span class="p">(</span><span class="n">pj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">.</span><span class="n">odata</span><span class="p">))</span>  <span class="c"># Prefix for output data</span>
        <span class="n">app</span><span class="p">(</span><span class="n">pj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">.</span><span class="n">tdata</span><span class="p">))</span>  <span class="c"># Prefix for temporary data</span>

        <span class="c"># Paths to the pseudopotential files.</span>
        <span class="c"># Note that here the pseudos **must** be sorted according to znucl.</span>
        <span class="c"># Here we reorder the pseudos if the order is wrong.</span>
        <span class="n">ord_pseudos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">znucl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">to_abivars</span><span class="p">()[</span><span class="s">&quot;znucl&quot;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">znucl</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">Z</span> <span class="o">==</span> <span class="n">z</span><span class="p">:</span>
                    <span class="n">ord_pseudos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Cannot find pseudo with znucl </span><span class="si">%s</span><span class="s"> in pseudos:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">pseudo</span> <span class="ow">in</span> <span class="n">ord_pseudos</span><span class="p">:</span>
            <span class="n">app</span><span class="p">(</span><span class="n">pseudo</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>

        <span class="k">return</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_pconfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pconfs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the list of autoparal configurations.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pconfs</span> <span class="o">=</span> <span class="n">pconfs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pconfs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List of autoparal configurations.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pconfs</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">autoparal_run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find an optimal set of parameters for the execution of the task </span>
<span class="sd">        This method can change the ABINIT input variables and/or the</span>
<span class="sd">        submission parameters e.g. the number of CPUs for MPI and OpenMp.</span>

<span class="sd">        Set:</span>
<span class="sd">           self.pconfs where pconfs is a :class:`ParalHints` object with the configuration reported by</span>
<span class="sd">           autoparal and optimal is the optimal configuration selected.</span>
<span class="sd">           Returns 0 if success</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;in autoparal_run&quot;</span><span class="p">)</span>
        <span class="n">policy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">policy</span>

        <span class="k">if</span> <span class="n">policy</span><span class="o">.</span><span class="n">autoparal</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c"># or policy.max_ncpus in [None, 1]:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Nothing to do in autoparal, returning (None, None)&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">policy</span><span class="o">.</span><span class="n">autoparal</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;autoparal != 1&quot;</span><span class="p">)</span>

        <span class="c">############################################################################</span>
        <span class="c"># Run ABINIT in sequential to get the possible configurations with max_ncpus</span>
        <span class="c">############################################################################</span>

        <span class="c"># Set the variables for automatic parallelization</span>
        <span class="c"># Will get all the possible configurations up to max_ncpus</span>
        <span class="n">max_ncpus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">max_cores</span>
        <span class="n">autoparal_vars</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">autoparal</span><span class="o">=</span><span class="n">policy</span><span class="o">.</span><span class="n">autoparal</span><span class="p">,</span> <span class="n">max_ncpus</span><span class="o">=</span><span class="n">max_ncpus</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">add_extra_abivars</span><span class="p">(</span><span class="n">autoparal_vars</span><span class="p">)</span>

        <span class="c"># Run the job in a shell subprocess with mpi_procs = 1</span>
        <span class="c"># we don&#39;t want to make a request to the queue manager for this simple job!</span>
        <span class="c"># Return code is always != 0 </span>
        <span class="n">process</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">to_shell_manager</span><span class="p">(</span><span class="n">mpi_procs</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">launch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;fake run launched&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">retcode</span> <span class="o">=</span> <span class="n">process</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>

        <span class="c"># Remove the variables added for the automatic parallelization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">remove_extra_abivars</span><span class="p">(</span><span class="n">autoparal_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c">##############################################################</span>
        <span class="c"># Parse the autoparal configurations from the main output file</span>
        <span class="c">##############################################################</span>
        <span class="n">parser</span> <span class="o">=</span> <span class="n">ParalHintsParser</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">pconfs</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">parser</span><span class="o">.</span><span class="n">Error</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;Error while parsing Autoparal section:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">straceback</span><span class="p">())</span>
            <span class="k">return</span> <span class="mi">2</span>

        <span class="c">######################################################</span>
        <span class="c"># Select the optimal configuration according to policy</span>
        <span class="c">######################################################</span>
        <span class="n">optconf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_optconf</span><span class="p">(</span><span class="n">pconfs</span><span class="p">)</span>

        <span class="c">####################################################</span>
        <span class="c"># Change the input file and/or the submission script</span>
        <span class="c">####################################################</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">add_extra_abivars</span><span class="p">(</span><span class="n">optconf</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span>

        <span class="c"># Write autoparal configurations to JSON file.</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">pconfs</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span>
        <span class="n">d</span><span class="p">[</span><span class="s">&quot;optimal_conf&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">optconf</span>
        <span class="n">json_pretty_dump</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;autoparal.json&quot;</span><span class="p">))</span>

        <span class="c">##############</span>
        <span class="c"># Finalization</span>
        <span class="c">##############</span>
        <span class="c"># Reset the status, remove garbage files ...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_INIT</span><span class="p">)</span>

        <span class="c"># Remove the output file since Abinit likes to create new files </span>
        <span class="c"># with extension .outA, .outB if the file already exists.</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stderr_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>

        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">find_optconf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pconfs</span><span class="p">):</span>
        <span class="c"># Save pconfs for future reference.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_pconfs</span><span class="p">(</span><span class="n">pconfs</span><span class="p">)</span>
                                                                                
        <span class="c"># Select the partition on which we&#39;ll be running and set MPI/OMP cores.</span>
        <span class="n">optconf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">select_qadapter</span><span class="p">(</span><span class="n">pconfs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">optconf</span>

    <span class="k">def</span> <span class="nf">get_ibz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ngkpt</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">shiftk</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function calls ABINIT to compute the list of k-points in the IBZ.</span>
<span class="sd">        By default, we use the value of ngkpt and shiftk in the strategy but it&#39;s also</span>
<span class="sd">        possible to change temporary these values.</span>

<span class="sd">        Returns:</span>
<span class="sd">            kpoints: numpy array with the reduced coordinates of the k-points in the IBZ.</span>
<span class="sd">            weights: numpy array with the weights normalized to one.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;in get_ibz&quot;</span><span class="p">)</span>

        <span class="c">#########################################</span>
        <span class="c"># Run ABINIT in sequential to get the IBZ</span>
        <span class="c">#########################################</span>

        <span class="c"># Set the variables for automatic parallelization</span>
        <span class="n">ibz_vars</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">prtkpt</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ngkpt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span> <span class="n">ibz_vars</span><span class="p">[</span><span class="s">&quot;ngkpt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ngkpt</span>
        <span class="k">if</span> <span class="n">shiftk</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">shiftk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resphape</span><span class="p">(</span><span class="n">shiftk</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
            <span class="n">ibz_vars</span><span class="p">[</span><span class="s">&quot;shiftk&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">shiftk</span>
            <span class="n">ibz_vars</span><span class="p">[</span><span class="s">&quot;nshiftk&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shiftk</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">add_extra_abivars</span><span class="p">(</span><span class="n">ibz_vars</span><span class="p">)</span>
        <span class="c"># Build a simple manager to run the job in a shell subprocess</span>
        <span class="c"># we don&#39;t want to make a request to the queue manager for this simple job!</span>
        <span class="n">seq_manager</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">to_shell_manager</span><span class="p">(</span><span class="n">mpi_procs</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c"># Return code is always != 0</span>
        <span class="n">process</span> <span class="o">=</span> <span class="n">seq_manager</span><span class="o">.</span><span class="n">launch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">retcode</span> <span class="o">=</span> <span class="n">process</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>

        <span class="c"># Remove the variables added for the automatic parallelization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">remove_extra_abivars</span><span class="p">(</span><span class="n">ibz_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c">################################################</span>
        <span class="c"># Read the list of k-points from the netcdf file</span>
        <span class="c">################################################</span>
        <span class="kn">from</span> <span class="nn">pymatgen.io.abinitio</span> <span class="kn">import</span> <span class="n">NetcdfReader</span>
        <span class="k">with</span> <span class="n">NetcdfReader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">path_in</span><span class="p">(</span><span class="s">&quot;kpts.nc&quot;</span><span class="p">))</span> <span class="k">as</span> <span class="n">r</span><span class="p">:</span>
            <span class="n">kpoints</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="s">&quot;reduced_coordinates_of_kpoints&quot;</span><span class="p">)</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="s">&quot;kpoint_weights&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_INIT</span><span class="p">)</span>

        <span class="c"># Remove the output file since Abinit likes to create new files</span>
        <span class="c"># with extension .outA, .outB if the file already exists.</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stderr_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">kpoints</span><span class="p">,</span> <span class="n">weights</span>

    <span class="k">def</span> <span class="nf">restart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        general restart used when scheduler problems have been taken care of</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">reset_from_scratch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        restart from scratch, reuse of output</span>
<span class="sd">        this is to be used if a job is restarted with more resources after a crash</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># remove all &#39;error&#39;, else the job will be seen as crashed in the next check status</span>
        <span class="c"># even if the job did not run</span>
        <span class="c"># print(&#39;reset_from_scatch&#39;, self)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_file</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stderr_file</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_lockfile</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span><span class="p">(</span><span class="n">submit</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fix_abi_critical</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        method to fix crashes/error caused by abinit</span>

<span class="sd">        Returns:</span>
<span class="sd">            1 if task has been fixed else 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">report</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_event_report</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">report</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">correct</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span> <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">count</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reset_from_scratch</span><span class="p">()</span>
            <span class="k">return</span> <span class="mi">1</span>

        <span class="n">info_msg</span> <span class="o">=</span> <span class="s">&#39;We encountered AbiCritical events that could not be fixed&#39;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="n">info_msg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="n">status</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">info_msg</span><span class="o">=</span><span class="n">info_msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">fix_queue_critical</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function tries to fix critical events originating from the queue submission system.</span>

<span class="sd">        General strategy, first try to increase resources in order to fix the problem,</span>
<span class="sd">        if this is not possible, call a task specific method to attempt to decrease the demands.</span>

<span class="sd">        Returns:</span>
<span class="sd">            1 if task has been fixed else 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pymatgen.io.abinitio.scheduler_error_parsers</span> <span class="kn">import</span> <span class="n">NodeFailureError</span><span class="p">,</span> <span class="n">MemoryCancelError</span><span class="p">,</span> <span class="n">TimeCancelError</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue_errors</span><span class="p">:</span>
            <span class="c"># queue error but no errors detected, try to solve by increasing resources</span>
            <span class="c"># if resources are at maximum the task is definitively turned to errored</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">increase_resources</span><span class="p">():</span>  <span class="c"># acts either on the policy or on the qadapter</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reset_from_scratch</span><span class="p">()</span>
                <span class="k">return</span> <span class="mi">1</span> 
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">info_msg</span><span class="o">=</span><span class="s">&#39;unknown queue error, could not increase resources any further&#39;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">error</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue_errors</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;fixing : </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="n">NodeFailureError</span><span class="p">):</span>
                    <span class="c"># if the problematic node is know exclude it</span>
                    <span class="k">if</span> <span class="n">error</span><span class="o">.</span><span class="n">nodes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">exclude_nodes</span><span class="p">(</span><span class="n">error</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">reset_from_scratch</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_READY</span><span class="p">,</span> <span class="n">info_msg</span><span class="o">=</span><span class="s">&#39;increased resources&#39;</span><span class="p">)</span>
                        <span class="k">return</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">info_msg</span><span class="o">=</span><span class="s">&#39;Node error but no node identified.&#39;</span><span class="p">)</span>

                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="n">MemoryCancelError</span><span class="p">):</span>
                    <span class="c"># ask the qadapter to provide more resources, i.e. more cpu&#39;s so more total memory</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">increase_resources</span><span class="p">():</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">reset_from_scratch</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_READY</span><span class="p">,</span> <span class="n">info_msg</span><span class="o">=</span><span class="s">&#39;increased mem&#39;</span><span class="p">)</span>
                        <span class="k">return</span> <span class="mi">1</span>

                    <span class="c"># if the max is reached, try to increase the memory per cpu:</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">increase_mem</span><span class="p">():</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">reset_from_scratch</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_READY</span><span class="p">,</span> <span class="n">info_msg</span><span class="o">=</span><span class="s">&#39;increased mem&#39;</span><span class="p">)</span>
                        <span class="k">return</span> <span class="mi">1</span>

                    <span class="c"># if this failed ask the self to provide a method to reduce the memory demand</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduce_memory_demand</span><span class="p">():</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">reset_from_scratch</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_READY</span><span class="p">,</span> <span class="n">info_msg</span><span class="o">=</span><span class="s">&#39;decreased mem demand&#39;</span><span class="p">)</span>
                        <span class="k">return</span> <span class="mi">1</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">info_msg</span> <span class="o">=</span> <span class="s">&#39;Memory error detected but the memory could not be increased neigther could the &#39;</span> \
                                   <span class="s">&#39;memory demand be decreased. Unrecoverable error.&#39;</span>
                        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">info_msg</span><span class="p">)</span>

                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="n">TimeCancelError</span><span class="p">):</span>
                    <span class="c"># ask the qadapter to provide more memory</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">increase_time</span><span class="p">():</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">reset_from_scratch</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_READY</span><span class="p">,</span> <span class="n">info_msg</span><span class="o">=</span><span class="s">&#39;increased wall time&#39;</span><span class="p">)</span>
                        <span class="k">return</span> <span class="mi">1</span>

                    <span class="c"># if this fails ask the qadapter to increase the number of cpus</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">increase_resources</span><span class="p">():</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">reset_from_scratch</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_READY</span><span class="p">,</span> <span class="n">info_msg</span><span class="o">=</span><span class="s">&#39;increased number of cpus&#39;</span><span class="p">)</span>
                        <span class="k">return</span> <span class="mi">1</span>

                    <span class="c"># if this failed ask the task to provide a method to speed up the task</span>
                    <span class="c"># MG TODO: Remove this</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">speed_up</span><span class="p">():</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">reset_from_scratch</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_READY</span><span class="p">,</span> <span class="n">info_msg</span><span class="o">=</span><span class="s">&#39;task speedup&#39;</span><span class="p">)</span>
                        <span class="k">return</span> <span class="mi">1</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">info_msg</span> <span class="o">=</span> <span class="s">&#39;Time cancel error detected but the time could not be increased neigther could &#39;</span> \
                                   <span class="s">&#39;the time demand be decreased by speedup of increasing the number of cpus. &#39;</span> \
                                   <span class="s">&#39;Unrecoverable error.&#39;</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">info_msg</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">info_msg</span> <span class="o">=</span> <span class="s">&#39;No solution provided for error </span><span class="si">%s</span><span class="s">. Unrecoverable error.&#39;</span> <span class="o">%</span> <span class="n">error</span><span class="o">.</span><span class="n">name</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">info_msg</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">info_msg</span><span class="p">)</span>

        <span class="k">return</span> <span class="mi">0</span>

<span class="c"># TODO</span>
<span class="c"># Enable restarting capabilites:</span>
<span class="c"># Before doing so I need:</span>
<span class="c">#   1) Preliminary standardization of the ABINT events and critical WARNINGS (YAML)</span>
<span class="c">#   2) Change the parser so that we can use strings in the input file.</span>
<span class="c">#      We need this change for restarting structural relaxations so that we can read </span>
<span class="c">#      the initial structure from file.</span>

<span class="k">class</span> <span class="nc">ProduceGsr</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mixin class for an :class:`AbinitTask` producing a GSR file.</span>
<span class="sd">    Provide the method `open_gsr` that reads and return a GSR file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gsr_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Absolute path of the GSR file. Empty string if file is not present.&quot;&quot;&quot;</span>
        <span class="c"># Lazy property to avoid multiple calls to has_abiext.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gsr_path</span> 
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s">&quot;GSR&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">path</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gsr_path</span> <span class="o">=</span> <span class="n">path</span>
            <span class="k">return</span> <span class="n">path</span>

    <span class="k">def</span> <span class="nf">open_gsr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Open the GSR file located in the in self.outdir.</span>
<span class="sd">        Returns :class:`GsrFile` object, None if file could not be found or file is not readable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gsr_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsr_path</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">gsr_path</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> reached S_OK but didn&#39;t produce a GSR file in </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="c"># Open the GSR file.</span>
        <span class="kn">from</span> <span class="nn">abipy.electrons.gsr</span> <span class="kn">import</span> <span class="n">GsrFile</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">GsrFile</span><span class="p">(</span><span class="n">gsr_path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;Exception while reading GSR file at </span><span class="si">%s</span><span class="s">:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">gsr_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">)))</span>
            <span class="k">return</span> <span class="bp">None</span>


<span class="k">class</span> <span class="nc">ProduceHist</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mixin class for an :class:`AbinitTask` producing a HIST file.</span>
<span class="sd">    Provide the method `open_hist` that reads and return a HIST file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">hist_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Absolute path of the HIST file. Empty string if file is not present.&quot;&quot;&quot;</span>
        <span class="c"># Lazy property to avoid multiple calls to has_abiext.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hist_path</span> 
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s">&quot;HIST&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">path</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hist_path</span> <span class="o">=</span> <span class="n">path</span>
            <span class="k">return</span> <span class="n">path</span>

    <span class="k">def</span> <span class="nf">open_hist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Open the HIST file located in the in self.outdir.</span>
<span class="sd">        Returns :class:`HistFile` object, None if file could not be found or file is not readable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">hist_path</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> reached S_OK but didn&#39;t produce a HIST file in </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="c"># Open the HIST file</span>
        <span class="kn">from</span> <span class="nn">abipy.dynamics.hist</span> <span class="kn">import</span> <span class="n">HistFile</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">HistFile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hist_path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;Exception while reading HIST file at </span><span class="si">%s</span><span class="s">:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hist_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">)))</span>
            <span class="k">return</span> <span class="bp">None</span>


<span class="k">class</span> <span class="nc">ProduceDdb</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mixin class for :an class:`AbinitTask` producing a DDB file.</span>
<span class="sd">    Provide the method `open_ddb` that reads and return a Ddb file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ddb_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Absolute path of the DDB file. Empty string if file is not present.&quot;&quot;&quot;</span>
        <span class="c"># Lazy property to avoid multiple calls to has_abiext.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ddb_path</span> 
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s">&quot;DDB&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">path</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ddb_path</span> <span class="o">=</span> <span class="n">path</span>
            <span class="k">return</span> <span class="n">path</span>

    <span class="k">def</span> <span class="nf">open_ddb</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Open the DDB file located in the in self.outdir.</span>
<span class="sd">        Returns :class:`DdbFile` object, None if file could not be found or file is not readable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ddb_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddb_path</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ddb_path</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> reached S_OK but didn&#39;t produce a DDB file in </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="c"># Open the GSR file.</span>
        <span class="kn">from</span> <span class="nn">abipy.dfpt.ddb</span> <span class="kn">import</span> <span class="n">DdbFile</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">DdbFile</span><span class="p">(</span><span class="n">ddb_path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;Exception while reading DDB file at </span><span class="si">%s</span><span class="s">:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ddb_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">)))</span>
            <span class="k">return</span> <span class="bp">None</span>


<div class="viewcode-block" id="ScfTask"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.ScfTask">[docs]</a><span class="k">class</span> <span class="nc">ScfTask</span><span class="p">(</span><span class="n">AbinitTask</span><span class="p">,</span> <span class="n">ProduceGsr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Self-consistent ground-state calculations.</span>
<span class="sd">    Provide support for in-place restart via (WFK|DEN) files</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CRITICAL_EVENTS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">events</span><span class="o">.</span><span class="n">ScfConvergenceWarning</span><span class="p">,</span>
    <span class="p">]</span>

<div class="viewcode-block" id="ScfTask.restart"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.ScfTask.restart">[docs]</a>    <span class="k">def</span> <span class="nf">restart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;SCF calculations can be restarted if we have either the WFK file or the DEN file.&quot;&quot;&quot;</span>
        <span class="c"># Prefer WFK over DEN files since we can reuse the wavefunctions.</span>
        <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&quot;WFK&quot;</span><span class="p">,</span> <span class="s">&quot;DEN&quot;</span><span class="p">):</span>
            <span class="n">restart_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
            <span class="n">irdvars</span> <span class="o">=</span> <span class="n">irdvars_for_ext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">restart_file</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">RestartError</span><span class="p">(</span><span class="s">&quot;Cannot find WFK or DEN file to restart from.&quot;</span><span class="p">)</span>

        <span class="c"># Move out --&gt; in.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out_to_in</span><span class="p">(</span><span class="n">restart_file</span><span class="p">)</span>

        <span class="c"># Add the appropriate variable for restarting.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">add_extra_abivars</span><span class="p">(</span><span class="n">irdvars</span><span class="p">)</span>

        <span class="c"># Now we can resubmit the job.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="ScfTask.inspect"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.ScfTask.inspect">[docs]</a>    <span class="k">def</span> <span class="nf">inspect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the SCF cycle results with matplotlib.</span>

<span class="sd">        Returns</span>
<span class="sd">            `matplotlib` figure, None if some error occurred.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">scf_cycle</span> <span class="o">=</span> <span class="n">abiinspect</span><span class="o">.</span><span class="n">GroundStateScfCycle</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="n">scf_cycle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="s">&quot;title&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&quot;title&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">scf_cycle</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">None</span>
</div>
<div class="viewcode-block" id="ScfTask.get_results"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.ScfTask.get_results">[docs]</a>    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">ScfTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_results</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c"># Open the GSR file and add its data to results.out</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_gsr</span><span class="p">()</span> <span class="k">as</span> <span class="n">gsr</span><span class="p">:</span>
            <span class="n">results</span><span class="p">[</span><span class="s">&quot;out&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">gsr</span><span class="o">.</span><span class="n">as_dict</span><span class="p">())</span>
            <span class="c"># Add files to GridFS</span>
            <span class="n">results</span><span class="o">.</span><span class="n">register_gridfs_files</span><span class="p">(</span><span class="n">GSR</span><span class="o">=</span><span class="n">gsr</span><span class="o">.</span><span class="n">filepath</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span>

</div></div>
<div class="viewcode-block" id="NscfTask"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.NscfTask">[docs]</a><span class="k">class</span> <span class="nc">NscfTask</span><span class="p">(</span><span class="n">AbinitTask</span><span class="p">,</span> <span class="n">ProduceGsr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Non-Self-consistent GS calculation.</span>
<span class="sd">    Provide in-place restart via WFK files</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CRITICAL_EVENTS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">events</span><span class="o">.</span><span class="n">NscfConvergenceWarning</span><span class="p">,</span>
    <span class="p">]</span>

<div class="viewcode-block" id="NscfTask.restart"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.NscfTask.restart">[docs]</a>    <span class="k">def</span> <span class="nf">restart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;NSCF calculations can be restarted only if we have the WFK file.&quot;&quot;&quot;</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="s">&quot;WFK&quot;</span>
        <span class="n">restart_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">restart_file</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">RestartError</span><span class="p">(</span><span class="s">&quot;Cannot find the WFK file to restart from.&quot;</span><span class="p">)</span>

        <span class="c"># Move out --&gt; in.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out_to_in</span><span class="p">(</span><span class="n">restart_file</span><span class="p">)</span>

        <span class="c"># Add the appropriate variable for restarting.</span>
        <span class="n">irdvars</span> <span class="o">=</span> <span class="n">irdvars_for_ext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">add_extra_abivars</span><span class="p">(</span><span class="n">irdvars</span><span class="p">)</span>

        <span class="c"># Now we can resubmit the job.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="NscfTask.get_results"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.NscfTask.get_results">[docs]</a>    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">NscfTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_results</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c"># Read the GSR file.</span>
        <span class="k">with</span>  <span class="bp">self</span><span class="o">.</span><span class="n">open_gsr</span><span class="p">()</span> <span class="k">as</span> <span class="n">gsr</span><span class="p">:</span>
            <span class="n">results</span><span class="p">[</span><span class="s">&quot;out&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">gsr</span><span class="o">.</span><span class="n">as_dict</span><span class="p">())</span>
            <span class="c"># Add files to GridFS</span>
            <span class="n">results</span><span class="o">.</span><span class="n">register_gridfs_files</span><span class="p">(</span><span class="n">GSR</span><span class="o">=</span><span class="n">gsr</span><span class="o">.</span><span class="n">filepath</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span>

</div></div>
<div class="viewcode-block" id="RelaxTask"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.RelaxTask">[docs]</a><span class="k">class</span> <span class="nc">RelaxTask</span><span class="p">(</span><span class="n">AbinitTask</span><span class="p">,</span> <span class="n">ProduceGsr</span><span class="p">,</span> <span class="n">ProduceHist</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Task for structural optimizations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># TODO possible ScfConvergenceWarning?</span>
    <span class="n">CRITICAL_EVENTS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">events</span><span class="o">.</span><span class="n">RelaxConvergenceWarning</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="nf">_change_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Change the input structure.&quot;&quot;&quot;</span>
        <span class="c">#print(&quot;changing structure&quot;)</span>
        <span class="c">#print(&quot;old:\n&quot; + str(self.strategy.abinit_input.structure) + &quot;\n&quot;)</span>
        <span class="c">#print(&quot;new:\n&quot; + str(structure) + &quot;\n&quot;)</span>

        <span class="c">#print(&quot;**old input**&quot;)</span>
        <span class="c">#print(self.make_input())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">abinit_input</span><span class="o">.</span><span class="n">set_structure</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span>
        <span class="c">#print(self.initial_structure)</span>
        <span class="c">#print(&quot;**new input**&quot;)</span>
        <span class="c">#print(self.make_input())</span>
        <span class="c">#self.build()</span>

<div class="viewcode-block" id="RelaxTask.read_final_structure"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.RelaxTask.read_final_structure">[docs]</a>    <span class="k">def</span> <span class="nf">read_final_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read the final structure from the GSR file.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_gsr</span><span class="p">()</span> <span class="k">as</span> <span class="n">gsr</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">gsr</span><span class="o">.</span><span class="n">structure</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;Cannot find the GSR file with the final structure to restart from.&quot;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="RelaxTask.restart"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.RelaxTask.restart">[docs]</a>    <span class="k">def</span> <span class="nf">restart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Restart the structural relaxation.</span>

<span class="sd">        Structure relaxations can be restarted only if we have the WFK file or the DEN or the GSR file.</span>
<span class="sd">        from which we can read the last structure (mandatory) and the wavefunctions (not mandatory but useful).</span>
<span class="sd">        Prefer WFK over other files since we can reuse the wavefunctions.</span>

<span class="sd">        .. note::</span>

<span class="sd">            The problem in the present approach is that some parameters in the input</span>
<span class="sd">            are computed from the initial structure and may not be consisten with</span>
<span class="sd">            the modification of the structure done during the structure relaxation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&quot;WFK&quot;</span><span class="p">,</span> <span class="s">&quot;DEN&quot;</span><span class="p">):</span>
            <span class="n">ofile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ofile</span><span class="p">:</span>
                <span class="n">irdvars</span> <span class="o">=</span> <span class="n">irdvars_for_ext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
                <span class="n">infile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_to_in</span><span class="p">(</span><span class="n">ofile</span><span class="p">)</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">RestartError</span><span class="p">(</span><span class="s">&quot;Cannot find the WFK|DEN file to restart from.&quot;</span><span class="p">)</span>

        <span class="c"># Add the appropriate variable for restarting.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">add_extra_abivars</span><span class="p">(</span><span class="n">irdvars</span><span class="p">)</span>

        <span class="c"># Read the relaxed structure from the GSR file.</span>
        <span class="n">structure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_final_structure</span><span class="p">()</span>
                                                           
        <span class="c"># Change the structure.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_change_structure</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span>

        <span class="c"># Now we can resubmit the job.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="RelaxTask.inspect"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.RelaxTask.inspect">[docs]</a>    <span class="k">def</span> <span class="nf">inspect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the evolution of the structural relaxation with matplotlib.</span>

<span class="sd">        Args:</span>
<span class="sd">            what: Either &quot;hist&quot; or &quot;scf&quot;. The first option (default) extracts data</span>
<span class="sd">                from the HIST file and plot the evolution of the structural </span>
<span class="sd">                parameters, forces, pressures and energies.</span>
<span class="sd">                The second option, extract data from the main output file and</span>
<span class="sd">                plot the evolution of the SCF cycles (etotal, residuals, etc).</span>

<span class="sd">        Returns</span>
<span class="sd">            `matplotlib` figure, None if some error occurred. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">what</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;what&quot;</span><span class="p">,</span> <span class="s">&quot;hist&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">what</span> <span class="o">==</span> <span class="s">&quot;hist&quot;</span><span class="p">:</span>
            <span class="c"># Read the hist file to get access to the structure.</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_hist</span><span class="p">()</span> <span class="k">as</span> <span class="n">hist</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">hist</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span> <span class="k">if</span> <span class="n">hist</span> <span class="k">else</span> <span class="bp">None</span>

        <span class="k">elif</span> <span class="n">what</span> <span class="o">==</span> <span class="s">&quot;scf&quot;</span><span class="p">:</span>
            <span class="c"># Get info on the different SCF cycles </span>
            <span class="n">relaxation</span> <span class="o">=</span> <span class="n">abiinspect</span><span class="o">.</span><span class="n">Relaxation</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
            <span class="k">if</span> <span class="s">&quot;title&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&quot;title&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">relaxation</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">if</span> <span class="n">relaxation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="bp">None</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Wrong value for what </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">what</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="RelaxTask.get_results"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.RelaxTask.get_results">[docs]</a>    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">RelaxTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_results</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c"># Open the GSR file and add its data to results.out</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_gsr</span><span class="p">()</span> <span class="k">as</span> <span class="n">gsr</span><span class="p">:</span>
            <span class="n">results</span><span class="p">[</span><span class="s">&quot;out&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">gsr</span><span class="o">.</span><span class="n">as_dict</span><span class="p">())</span>
            <span class="c"># Add files to GridFS</span>
            <span class="n">results</span><span class="o">.</span><span class="n">register_gridfs_files</span><span class="p">(</span><span class="n">GSR</span><span class="o">=</span><span class="n">gsr</span><span class="o">.</span><span class="n">filepath</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span>

</div></div>
<span class="k">class</span> <span class="nc">DdeTask</span><span class="p">(</span><span class="n">AbinitTask</span><span class="p">,</span> <span class="n">ProduceDdb</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Task for DDE calculations.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">DdeTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_results</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">results</span><span class="o">.</span><span class="n">register_gridfs_file</span><span class="p">(</span><span class="n">DDB</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s">&quot;DDE&quot;</span><span class="p">),</span> <span class="s">&quot;t&quot;</span><span class="p">))</span>


<div class="viewcode-block" id="DdkTask"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.DdkTask">[docs]</a><span class="k">class</span> <span class="nc">DdkTask</span><span class="p">(</span><span class="n">AbinitTask</span><span class="p">,</span> <span class="n">ProduceDdb</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Task for DDK calculations.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_on_ok</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DdkTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_on_ok</span><span class="p">()</span>
        <span class="c"># Copy instead of removing, otherwise optic tests fail</span>
        <span class="c"># Fixing this proble requires a rationalization of file extensions.</span>
        <span class="c">#if self.outdir.rename_abiext(&#39;1WF&#39;, &#39;DDK&#39;) &gt; 0:</span>
        <span class="c">#if self.outdir.copy_abiext(&#39;1WF&#39;, &#39;DDK&#39;) &gt; 0:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">symlink_abiext</span><span class="p">(</span><span class="s">&#39;1WF&#39;</span><span class="p">,</span> <span class="s">&#39;DDK&#39;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span>

<div class="viewcode-block" id="DdkTask.get_results"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.DdkTask.get_results">[docs]</a>    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">DdkTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_results</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">results</span><span class="o">.</span><span class="n">register_gridfs_file</span><span class="p">(</span><span class="n">DDK</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s">&quot;DDK&quot;</span><span class="p">),</span> <span class="s">&quot;t&quot;</span><span class="p">))</span>

</div></div>
<div class="viewcode-block" id="PhononTask"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.PhononTask">[docs]</a><span class="k">class</span> <span class="nc">PhononTask</span><span class="p">(</span><span class="n">AbinitTask</span><span class="p">,</span> <span class="n">ProduceDdb</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    DFPT calculations for a single atomic perturbation.</span>
<span class="sd">    Provide support for in-place restart via (1WF|1DEN) files</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># TODO: </span>
    <span class="c"># for the time being we don&#39;t discern between GS and PhononCalculations.</span>
    <span class="c"># Restarting Phonon calculation is more difficult due to the crazy rules employed in ABINIT </span>
    <span class="n">CRITICAL_EVENTS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">events</span><span class="o">.</span><span class="n">ScfConvergenceWarning</span><span class="p">,</span>
    <span class="p">]</span>

<div class="viewcode-block" id="PhononTask.restart"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.PhononTask.restart">[docs]</a>    <span class="k">def</span> <span class="nf">restart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Phonon calculations can be restarted only if we have the 1WF file or the 1DEN file.</span>
<span class="sd">        from which we can read the first-order wavefunctions or the first order density.</span>
<span class="sd">        Prefer 1WF over 1DEN since we can reuse the wavefunctions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#self.fix_ofiles()</span>
        <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&quot;1WF&quot;</span><span class="p">,</span> <span class="s">&quot;1DEN&quot;</span><span class="p">):</span>
            <span class="n">restart_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
            <span class="n">irdvars</span> <span class="o">=</span> <span class="n">irdvars_for_ext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">restart_file</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">RestartError</span><span class="p">(</span><span class="s">&quot;Cannot find the 1WF|1DEN|file to restart from.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">out_to_in</span><span class="p">(</span><span class="n">restart_file</span><span class="p">)</span>

        <span class="c"># Add the appropriate variable for restarting.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">add_extra_abivars</span><span class="p">(</span><span class="n">irdvars</span><span class="p">)</span>

        <span class="c"># Now we can resubmit the job.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="PhononTask.inspect"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.PhononTask.inspect">[docs]</a>    <span class="k">def</span> <span class="nf">inspect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the Phonon SCF cycle results with matplotlib.</span>

<span class="sd">        Returns:</span>
<span class="sd">            `matplotlib` figure, None if some error occurred.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scf_cycle</span> <span class="o">=</span> <span class="n">abiinspect</span><span class="o">.</span><span class="n">PhononScfCycle</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">scf_cycle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="s">&quot;title&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&quot;title&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">scf_cycle</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="PhononTask.get_results"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.PhononTask.get_results">[docs]</a>    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">PhononTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_results</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">results</span><span class="o">.</span><span class="n">register_gridfs_file</span><span class="p">(</span><span class="n">DDB</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s">&quot;DDB&quot;</span><span class="p">),</span> <span class="s">&quot;t&quot;</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="PhononTask.make_links"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.PhononTask.make_links">[docs]</a>    <span class="k">def</span> <span class="nf">make_links</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PhononTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">make_links</span><span class="p">()</span>
        <span class="c"># fix the problem that abinit uses hte 1WF extension for the DDK output file but reads it with the irdddk flag</span>
        <span class="c">#if self.indir.has_abiext(&#39;DDK&#39;):</span>
        <span class="c">#    self.indir.rename_abiext(&#39;DDK&#39;, &#39;1WF&#39;)</span>

</div></div>
<span class="k">class</span> <span class="nc">ScrTask</span><span class="p">(</span><span class="n">AbinitTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Tasks for SCREENING calculations &quot;&quot;&quot;</span>
    <span class="c">#def inspect(self, **kwargs):</span>
    <span class="c">#    &quot;&quot;&quot;Plot graph showing the number of q-points computed and the wall-time used&quot;&quot;&quot;</span>


<div class="viewcode-block" id="SigmaTask"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.SigmaTask">[docs]</a><span class="k">class</span> <span class="nc">SigmaTask</span><span class="p">(</span><span class="n">AbinitTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tasks for SIGMA calculations. Provides support for in-place restart via QPS files</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CRITICAL_EVENTS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">events</span><span class="o">.</span><span class="n">QPSConvergenceWarning</span><span class="p">,</span>
    <span class="p">]</span>

<div class="viewcode-block" id="SigmaTask.restart"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.SigmaTask.restart">[docs]</a>    <span class="k">def</span> <span class="nf">restart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># G calculations can be restarted only if we have the QPS file </span>
        <span class="c"># from which we can read the results of the previous step.</span>
        <span class="n">restart_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s">&quot;QPS&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">restart_file</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">RestartError</span><span class="p">(</span><span class="s">&quot;Cannot find the QPS file to restart from.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">out_to_in</span><span class="p">(</span><span class="n">restart_file</span><span class="p">)</span>

        <span class="c"># Add the appropriate variable for restarting.</span>
        <span class="n">irdvars</span> <span class="o">=</span> <span class="n">irdvars_for_ext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">add_extra_abivars</span><span class="p">(</span><span class="n">irdvars</span><span class="p">)</span>

        <span class="c"># Now we can resubmit the job.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span><span class="p">()</span>

    <span class="c">#def inspect(self, **kwargs):</span>
    <span class="c">#    &quot;&quot;&quot;Plot graph showing the number of k-points computed and the wall-time used&quot;&quot;&quot;</span>
</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sigres_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Absolute path of the SIGRES file. Empty string if file is not present.&quot;&quot;&quot;</span>
        <span class="c"># Lazy property to avoid multiple calls to has_abiext.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sigres_path</span> 
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s">&quot;SIGRES&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">path</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sigres_path</span> <span class="o">=</span> <span class="n">path</span>
            <span class="k">return</span> <span class="n">path</span>

<div class="viewcode-block" id="SigmaTask.open_sigres"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.SigmaTask.open_sigres">[docs]</a>    <span class="k">def</span> <span class="nf">open_sigres</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Open the SIGRES file located in the in self.outdir. </span>
<span class="sd">        Returns SigresFile object, None if file could not be found or file is not readable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sigres_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigres_path</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">sigres_path</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> didn&#39;t produce a SIGRES file in </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="c"># Open the GSR file and add its data to results.out</span>
        <span class="kn">from</span> <span class="nn">abipy.electrons.gw</span> <span class="kn">import</span> <span class="n">SigresFile</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SigresFile</span><span class="p">(</span><span class="n">sigres_path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;Exception while reading SIGRES file at </span><span class="si">%s</span><span class="s">:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sigres_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">)))</span>
            <span class="k">return</span> <span class="bp">None</span>
</div>
<div class="viewcode-block" id="SigmaTask.get_scissors_builder"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.SigmaTask.get_scissors_builder">[docs]</a>    <span class="k">def</span> <span class="nf">get_scissors_builder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an instance of :class:`ScissorsBuilder` from the SIGRES file.</span>

<span class="sd">        Raise:</span>
<span class="sd">            RuntimeError if SIGRES file is not found</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">abipy.electrons.scissors</span> <span class="kn">import</span> <span class="n">ScissorsBuilder</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigres_path</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ScissorsBuilder</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigres_path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;Cannot find SIGRES file!&quot;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="SigmaTask.get_results"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.SigmaTask.get_results">[docs]</a>    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">SigmaTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_results</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c"># Open the SIGRES file and add its data to results.out</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_sigres</span><span class="p">()</span> <span class="k">as</span> <span class="n">sigres</span><span class="p">:</span>
            <span class="c">#results[&quot;out&quot;].update(sigres.as_dict())</span>
            <span class="n">results</span><span class="o">.</span><span class="n">register_gridfs_files</span><span class="p">(</span><span class="n">SIGRES</span><span class="o">=</span><span class="n">sigres</span><span class="o">.</span><span class="n">filepath</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span>

</div></div>
<span class="k">class</span> <span class="nc">BseTask</span><span class="p">(</span><span class="n">AbinitTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Task for Bethe-Salpeter calculations.</span>

<span class="sd">    .. note::</span>

<span class="sd">        The BSE codes provides both iterative and direct schemes for the computation of the dielectric function.</span>
<span class="sd">        The direct diagonalization cannot be restarted whereas Haydock and CG support restarting.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CRITICAL_EVENTS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">events</span><span class="o">.</span><span class="n">HaydockConvergenceWarning</span><span class="p">,</span>
        <span class="c">#events.BseIterativeDiagoConvergenceWarning,</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="nf">restart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        BSE calculations with Haydock can be restarted only if we have the</span>
<span class="sd">        excitonic Hamiltonian and the HAYDR_SAVE file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># TODO: This version seems to work but the main output file is truncated</span>
        <span class="c"># TODO: Handle restart if CG method is used</span>
        <span class="c"># TODO: restart should receive a list of critical events</span>
        <span class="c"># the log file is complete though.</span>
        <span class="n">irdvars</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c"># Move the BSE blocks to indata.</span>
        <span class="c"># This is done only once at the end of the first run.</span>
        <span class="c"># Successive restarts will use the BSR|BSC files in the indir directory</span>
        <span class="c"># to initialize the excitonic Hamiltonian</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&quot;BSR&quot;</span><span class="p">,</span> <span class="s">&quot;BSC&quot;</span><span class="p">):</span>
            <span class="n">ofile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ofile</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">irdvars</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">irdvars_for_ext</span><span class="p">(</span><span class="n">ext</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">out_to_in</span><span class="p">(</span><span class="n">ofile</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">count</span><span class="p">:</span>
            <span class="c"># outdir does not contain the BSR|BSC file.</span>
            <span class="c"># This means that num_restart &gt; 1 and the files should be in task.indir</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&quot;BSR&quot;</span><span class="p">,</span> <span class="s">&quot;BSC&quot;</span><span class="p">):</span>
                <span class="n">ifile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ifile</span><span class="p">:</span>
                    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">count</span><span class="p">:</span>
                <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">RestartError</span><span class="p">(</span><span class="s">&quot;Cannot find BSR|BSC files in </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">indir</span><span class="p">)</span>

        <span class="c"># Rename HAYDR_SAVE files</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&quot;HAYDR_SAVE&quot;</span><span class="p">,</span> <span class="s">&quot;HAYDC_SAVE&quot;</span><span class="p">):</span>
            <span class="n">ofile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ofile</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">irdvars</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">irdvars_for_ext</span><span class="p">(</span><span class="n">ext</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">out_to_in</span><span class="p">(</span><span class="n">ofile</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">count</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">RestartError</span><span class="p">(</span><span class="s">&quot;Cannot find the HAYDR_SAVE file to restart from.&quot;</span><span class="p">)</span>

        <span class="c"># Add the appropriate variable for restarting.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">add_extra_abivars</span><span class="p">(</span><span class="n">irdvars</span><span class="p">)</span>

        <span class="c"># Now we can resubmit the job.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span><span class="p">()</span>

    <span class="c">#def inspect(self, **kwargs):</span>
    <span class="c">#    &quot;&quot;&quot;</span>
    <span class="c">#    Plot the Haydock iterations with matplotlib.</span>
    <span class="c">#</span>
    <span class="c">#    Returns</span>
    <span class="c">#        `matplotlib` figure, None if some error occurred.</span>
    <span class="c">#    &quot;&quot;&quot;</span>
    <span class="c">#    haydock_cycle = abiinspect.HaydockIterations.from_file(self.output_file.path)</span>
    <span class="c">#    if haydock_cycle is not None:</span>
    <span class="c">#        if &quot;title&quot; not in kwargs: kwargs[&quot;title&quot;] = str(self)</span>
    <span class="c">#        return haydock_cycle.plot(**kwargs)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mdf_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Absolute path of the MDF file. Empty string if file is not present.&quot;&quot;&quot;</span>
        <span class="c"># Lazy property to avoid multiple calls to has_abiext.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mdf_path</span> 
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s">&quot;MDF.nc&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">path</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mdf_path</span> <span class="o">=</span> <span class="n">path</span>
            <span class="k">return</span> <span class="n">path</span>

    <span class="k">def</span> <span class="nf">open_mdf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Open the MDF file located in the in self.outdir.</span>
<span class="sd">        Returns `MdfFile` object, None if file could not be found or file is not readable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mdf_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdf_path</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">mdf_path</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> didn&#39;t produce a MDF file in </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="c"># Open the DFF file and add its data to results.out</span>
        <span class="kn">from</span> <span class="nn">abipy.electrons.bse</span> <span class="kn">import</span> <span class="n">MdfFile</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">MdfFile</span><span class="p">(</span><span class="n">mdf_path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;Exception while reading MDF file at </span><span class="si">%s</span><span class="s">:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">mdf_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">)))</span>
            <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">BseTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_results</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_mdf</span><span class="p">()</span> <span class="k">as</span> <span class="n">mdf</span><span class="p">:</span>
            <span class="c">#results[&quot;out&quot;].update(mdf.as_dict())</span>
            <span class="c">#epsilon_infinity optical_gap</span>
            <span class="n">results</span><span class="o">.</span><span class="n">register_gridfs_files</span><span class="p">(</span><span class="n">MDF</span><span class="o">=</span><span class="n">mdf</span><span class="o">.</span><span class="n">filepath</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span>


<div class="viewcode-block" id="OpticTask"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.OpticTask">[docs]</a><span class="k">class</span> <span class="nc">OpticTask</span><span class="p">(</span><span class="n">Task</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Task for the computation of optical spectra with optic i.e.</span>
<span class="sd">    RPA without local-field effects and velocity operator computed from DDK files.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">optic_input</span><span class="p">,</span> <span class="n">nscf_node</span><span class="p">,</span> <span class="n">ddk_nodes</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an instance of :class:`OpticTask` from an string containing the input.</span>
<span class="sd">    </span>
<span class="sd">        Args:</span>
<span class="sd">            optic_input: string with the optic variables (filepaths will be added at run time).</span>
<span class="sd">            nscf_node: The NSCF task that will produce thw WFK file or string with the path of the WFK file.</span>
<span class="sd">            ddk_nodes: List of :class:`DdkTask` nodes that will produce the DDK files or list of DDF paths.</span>
<span class="sd">            workdir: Path to the working directory.</span>
<span class="sd">            manager: :class:`TaskManager` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Convert paths to FileNodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nscf_node</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">as_node</span><span class="p">(</span><span class="n">nscf_node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ddk_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">Node</span><span class="o">.</span><span class="n">as_node</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">ddk_nodes</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ddk_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
        <span class="c">#print(self.nscf_node, self.ddk_nodes)</span>

        <span class="c"># Use DDK extension instead of 1WF</span>
        <span class="n">deps</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="s">&quot;1WF&quot;</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddk_nodes</span><span class="p">}</span>
        <span class="c">#deps = {n: &quot;DDK&quot; for n in self.ddk_nodes}</span>
        <span class="n">deps</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">nscf_node</span><span class="p">:</span> <span class="s">&quot;WFK&quot;</span><span class="p">})</span>

        <span class="n">strategy</span> <span class="o">=</span> <span class="n">OpticInput</span><span class="p">(</span><span class="n">optic_input</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">OpticTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">strategy</span><span class="o">=</span><span class="n">strategy</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="n">deps</span><span class="p">)</span>

<div class="viewcode-block" id="OpticTask.set_workdir"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.OpticTask.set_workdir">[docs]</a>    <span class="k">def</span> <span class="nf">set_workdir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">workdir</span><span class="p">,</span> <span class="n">chroot</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the working directory of the task.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">OpticTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">set_workdir</span><span class="p">(</span><span class="n">workdir</span><span class="p">,</span> <span class="n">chroot</span><span class="o">=</span><span class="n">chroot</span><span class="p">)</span>
        <span class="c"># Small hack: the log file of optics is actually the main output file. </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_file</span>
</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">executable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Path to the executable required for running the :class:`OpticTask`.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_executable</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;optic&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">filesfile_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String with the list of files and prefixes needed to execute ABINIT.&quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>

        <span class="c">#optic.in     ! Name of input file</span>
        <span class="c">#optic.out    ! Unused</span>
        <span class="c">#optic        ! Root name for all files that will be produced</span>
        <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>                           <span class="c"># Path to the input file</span>
        <span class="n">app</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;unused&quot;</span><span class="p">))</span>           <span class="c"># Path to the output file</span>
        <span class="n">app</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">.</span><span class="n">odata</span><span class="p">))</span>  <span class="c"># Prefix for output data</span>

        <span class="k">return</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">wfk_filepath</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns (at runtime) the absolute path of the WFK file produced by the NSCF run.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nscf_node</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s">&quot;WFK&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ddk_filepaths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns (at runtime) the absolute path of the DDK files produced by the DDK runs.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">ddk_task</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s">&quot;1WF&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">ddk_task</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddk_nodes</span><span class="p">]</span>

<div class="viewcode-block" id="OpticTask.make_input"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.OpticTask.make_input">[docs]</a>    <span class="k">def</span> <span class="nf">make_input</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct and write the input file of the calculation.&quot;&quot;&quot;</span>
        <span class="c"># Set the file paths.</span>
        <span class="n">files</span> <span class="o">=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ddk_filepaths</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">wfk_filepath</span><span class="p">])</span> <span class="o">+</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>

        <span class="c"># Get the input specified by the user</span>
        <span class="n">user_inp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">make_input</span><span class="p">()</span>

        <span class="c"># Join them.</span>
        <span class="k">return</span> <span class="n">files</span> <span class="o">+</span> <span class="n">user_inp</span>
</div>
<div class="viewcode-block" id="OpticTask.setup"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.OpticTask.setup">[docs]</a>    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Public method called before submitting the task.&quot;&quot;&quot;</span>
</div>
<div class="viewcode-block" id="OpticTask.make_links"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.OpticTask.make_links">[docs]</a>    <span class="k">def</span> <span class="nf">make_links</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Optic allows the user to specify the paths of the input file.</span>
<span class="sd">        hence we don&#39;t need to create symbolic links.</span>
<span class="sd">        &quot;&quot;&quot;</span>
</div>
<div class="viewcode-block" id="OpticTask.get_results"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.OpticTask.get_results">[docs]</a>    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">OpticTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_results</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c">#results.update(</span>
        <span class="c">#&quot;epsilon_infinity&quot;:</span>
        <span class="c">#))</span>
        <span class="k">return</span> <span class="n">results</span>

</div></div>
<div class="viewcode-block" id="AnaddbTask"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.AnaddbTask">[docs]</a><span class="k">class</span> <span class="nc">AnaddbTask</span><span class="p">(</span><span class="n">Task</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Task for Anaddb runs (post-processing of DFPT calculations).&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">anaddb_input</span><span class="p">,</span> <span class="n">ddb_node</span><span class="p">,</span>
                 <span class="n">gkk_node</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">md_node</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ddk_node</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an instance of :class:`AnaddbTask` from an string containing the input.</span>

<span class="sd">        Args:</span>
<span class="sd">            anaddb_input: string with the anaddb variables.</span>
<span class="sd">            ddb_node: The node that will produce the DDB file. Accept :class:`Task`, :class:`Work` or filepath.</span>
<span class="sd">            gkk_node: The node that will produce the GKK file (optional). Accept :class:`Task`, :class:`Work` or filepath.</span>
<span class="sd">            md_node: The node that will produce the MD file (optional). Accept `Task`, `Work` or filepath.</span>
<span class="sd">            gkk_node: The node that will produce the GKK file (optional). Accept `Task`, `Work` or filepath.</span>
<span class="sd">            workdir: Path to the working directory (optional).</span>
<span class="sd">            manager: :class:`TaskManager` object (optional).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Keep a reference to the nodes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ddb_node</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">as_node</span><span class="p">(</span><span class="n">ddb_node</span><span class="p">)</span>
        <span class="n">deps</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ddb_node</span><span class="p">:</span> <span class="s">&quot;DDB&quot;</span><span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">gkk_node</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">as_node</span><span class="p">(</span><span class="n">gkk_node</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gkk_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">deps</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">gkk_node</span><span class="p">:</span> <span class="s">&quot;GKK&quot;</span><span class="p">})</span>

        <span class="c"># I never used it!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">md_node</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">as_node</span><span class="p">(</span><span class="n">md_node</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">md_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">deps</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">md_node</span><span class="p">:</span> <span class="s">&quot;MD&quot;</span><span class="p">})</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ddk_node</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">as_node</span><span class="p">(</span><span class="n">ddk_node</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddk_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">deps</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">ddk_node</span><span class="p">:</span> <span class="s">&quot;DDK&quot;</span><span class="p">})</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">AnaddbTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">strategy</span><span class="o">=</span><span class="n">anaddb_input</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="n">deps</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">executable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Path to the executable required for running the :class:`AnaddbTask`.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_executable</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;anaddb&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">filesfile_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String with the list of files and prefixes needed to execute ABINIT.&quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>

        <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>          <span class="c"># 1) Path of the input file</span>
        <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>         <span class="c"># 2) Path of the output file</span>
        <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ddb_filepath</span><span class="p">)</span>             <span class="c"># 3) Input derivative database e.g. t13.ddb.in</span>
        <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">md_filepath</span><span class="p">)</span>              <span class="c"># 4) Output molecular dynamics e.g. t13.md</span>
        <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gkk_filepath</span><span class="p">)</span>             <span class="c"># 5) Input elphon matrix elements  (GKK file)</span>
        <span class="c"># FIXME check this one</span>
        <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">path_join</span><span class="p">(</span><span class="s">&quot;out&quot;</span><span class="p">))</span>  <span class="c"># 6) Base name for elphon output files e.g. t13</span>
        <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ddk_filepath</span><span class="p">)</span>             <span class="c"># 7) File containing ddk filenames for elphon/transport.</span>

        <span class="k">return</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ddb_filepath</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns (at runtime) the absolute path of the input DDB file.&quot;&quot;&quot;</span>
        <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddb_node</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s">&quot;DDB&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">path</span> <span class="k">if</span> <span class="n">path</span> <span class="k">else</span> <span class="s">&quot;DDB_FILE_DOES_NOT_EXIST&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">md_filepath</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns (at runtime) the absolute path of the input MD file.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">md_node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;MD_FILE_DOES_NOT_EXIST&quot;</span>

        <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">md_node</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s">&quot;MD&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">path</span> <span class="k">if</span> <span class="n">path</span> <span class="k">else</span> <span class="s">&quot;MD_FILE_DOES_NOT_EXIST&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gkk_filepath</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns (at runtime) the absolute path of the input GKK file.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gkk_node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;GKK_FILE_DOES_NOT_EXIST&quot;</span>

        <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gkk_node</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s">&quot;GKK&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">path</span> <span class="k">if</span> <span class="n">path</span> <span class="k">else</span> <span class="s">&quot;GKK_FILE_DOES_NOT_EXIST&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ddk_filepath</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns (at runtime) the absolute path of the input DKK file.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddk_node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;DDK_FILE_DOES_NOT_EXIST&quot;</span>

        <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddk_node</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s">&quot;DDK&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">path</span> <span class="k">if</span> <span class="n">path</span> <span class="k">else</span> <span class="s">&quot;DDK_FILE_DOES_NOT_EXIST&quot;</span>

<div class="viewcode-block" id="AnaddbTask.setup"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.AnaddbTask.setup">[docs]</a>    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Public method called before submitting the task.&quot;&quot;&quot;</span>
</div>
<div class="viewcode-block" id="AnaddbTask.make_links"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.AnaddbTask.make_links">[docs]</a>    <span class="k">def</span> <span class="nf">make_links</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Anaddb allows the user to specify the paths of the input file.</span>
<span class="sd">        hence we don&#39;t need to create symbolic links.</span>
<span class="sd">        &quot;&quot;&quot;</span>
</div>
<div class="viewcode-block" id="AnaddbTask.open_phbst"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.AnaddbTask.open_phbst">[docs]</a>    <span class="k">def</span> <span class="nf">open_phbst</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Open PHBST file produced by Anaddb and returns :class:`PhbstFile` object.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">abipy.dfpt.phonons</span> <span class="kn">import</span> <span class="n">PhbstFile</span>
        <span class="n">phbst_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;run.abo_PHBST.nc&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">phbst_path</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> reached S_OK but didn&#39;t produce a PHBST file in </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">PhbstFile</span><span class="p">(</span><span class="n">phbst_path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;Exception while reading GSR file at </span><span class="si">%s</span><span class="s">:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">phbst_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">)))</span>
            <span class="k">return</span> <span class="bp">None</span>
</div>
<div class="viewcode-block" id="AnaddbTask.open_phdos"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.AnaddbTask.open_phdos">[docs]</a>    <span class="k">def</span> <span class="nf">open_phdos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Open PHDOS file produced by Anaddb and returns :class:`PhdosFile` object.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">abipy.dfpt.phonons</span> <span class="kn">import</span> <span class="n">PhdosFile</span>
        <span class="n">phdos_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;run.abo_PHDOS.nc&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">phdos_path</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> reached S_OK but didn&#39;t produce a PHBST file in </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">PhdosFile</span><span class="p">(</span><span class="n">phdos_path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;Exception while reading GSR file at </span><span class="si">%s</span><span class="s">:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">phdos_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">)))</span>
            <span class="k">return</span> <span class="bp">None</span>
</div>
<div class="viewcode-block" id="AnaddbTask.get_results"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.AnaddbTask.get_results">[docs]</a>    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">AnaddbTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_results</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">results</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">pymatgen 3.1.7 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2011, Shyue Ping Ong, Anubhav Jain, Geoffroy Hautier, William Davidson Richard, Stephen Dacek, Sai Jayaraman, Michael Kocher, Dan Gunter, Shreyas Cholia, Vincent L Chevrier, Rickard Armiento.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
<div class="footer">This page uses <a href="http://analytics.google.com/">
Google Analytics</a> to collect statistics. You can disable it by blocking
the JavaScript coming from www.google-analytics.com.
<script type="text/javascript">
  (function() {
    var ga = document.createElement('script');
    ga.src = ('https:' == document.location.protocol ?
              'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    ga.setAttribute('async', 'true');
    document.documentElement.firstChild.appendChild(ga);
  })();
</script>
</div>

  </body>
</html>